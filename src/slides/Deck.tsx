import React from "react";
import {Box, Deck, Grid, Notes, Slide, Quote, Image, FullSizeImage} from "spectacle";

import tweet from "../img/tweet-1886192184808149383.png";

// Minimal placeholder visual block for assets (images/diagrams/memes/charts)
const Visual: React.FC<{ label: string; height?: string }> = ({label, height = "60vh"}) => (
  <Box
    style={{
      height,
      border: "3px dashed currentColor",
      borderRadius: "14px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      padding: "1rem",
      fontSize: "1.1rem",
      textAlign: "center",
      lineHeight: 1.35,
      whiteSpace: "pre-wrap",
    }}
  >
    {label}
  </Box>
);

// Small two-up placeholder grid
const TwoUp: React.FC<{ left: string; right: string }> = ({left, right}) => (
  <Grid gridTemplateColumns="1fr 1fr" columnGap={24}>
    <Visual label={left} height="56vh"/>
    <Visual label={right} height="56vh"/>
  </Grid>
);

// Three-up icons row
const ThreeUp: React.FC<{ a: string; b: string; c: string }> = ({a, b, c}) => (
  <Grid gridTemplateColumns="1fr 1fr 1fr" columnGap={18}>
    <Visual label={a} height="40vh"/>
    <Visual label={b} height="40vh"/>
    <Visual label={c} height="40vh"/>
  </Grid>
);

export default function DeckComponent() {
  return (
    <Deck>
      {/* 1 — Титул: абстрактная обложка */}
      <Slide>
        <Visual
          label={`TITLE ARTWORK / COVER\nВайбкодинг — блажь или благо?\nАбстрактная графика/паттерн без текста речи`}/>
        <Notes>
          <ul>
            <li>Короткое приветствие. «Я Илья, релиз/DevProd/билд-инженер в inDrive: мобильные CI/CD, релизный поезд,
              сторы».
            </li>
            <li>Обещание пользы: что такое вайбкодинг, где он работает, где нет; как превратить магию в процесс.</li>
            <li>Тон: лёгкий, без лишнего технического жаргона на старте.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <center>
          <Image src={tweet} width={"54%"}/>
        </center>
        <Notes>
          <ul>
            <li>Термин популяризовал Андрей Карпаты. Показываю источник — чтобы синхронизировать терминологию.</li>
            <li>Дам практическое определение и рамки: где уместно, где опасно.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 3 — Определение/рамка */}
      <Slide>
        <Visual
          label={`СХЕМА: «Поведение ↔ Код»\nПлашка: «LLM генерит код → я управляю поведением\nчерез промпты и итерации, часто почти не читая код»`}/>
        <Notes>
          <ul>
            <li>Моё практическое определение: код пишет LLM, я управляю итогом по поведению.</li>
            <li>Сразу оговорка: это инструмент, а не замена инженера. Ключ — где не читать окей, а где нельзя.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 4 — Ось понимания/чтения кода */}
      <Slide>
        <Visual
          label={`ОСЬ ИЗ ВИДЕО: 2D-матрица\nГоризонталь: «what's a computer? ↔ LeetCode killer»\nВертикаль: «wait, you read this? ↔ my life is git diffs»\nЗона «ниже порога чтения» выделена`}/>
        <Notes>
          <ul>
            <li>Куда попадает вайбкодинг: ниже порога систематического чтения кода, но у людей, которые в принципе могут
              читать.
            </li>
            <li>Для «не-строителей» (слева внизу) вайб ломается — всё равно нужен навык чтения/понимания.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 5 — Таймлайн моего пути */}
      <Slide>
        <Visual
          label={`ТАЙМЛАЙН: ранние эксперименты (~март 2023/2024) →\n«чистый вайб» (октябрь 2024)\n[TODO: уточнить даты]`}/>
        <Notes>
          <ul>
            <li>Коротко: пробовал раньше (дату уточню), а «чистый вайб» — октябрь 2024.</li>
            <li>Дальше — два кейса: сначала похмелье (бот), потом удача (рефакторинг с тестами).</li>
          </ul>
        </Notes>
      </Slide>

      {/* 6 — Кейс 1: боль (спам) */}
      <Slide>
        <Visual
          label={`ГРАФИК: «Сообщения-спам по дням»\nИконки чатов (100–4k участников)\nВизуально — боль и всплески`}/>
        <Notes>
          <ul>
            <li>Я админ нескольких чатов; вал спама — реальная боль.</li>
            <li>Контекст для MVP: «давайте автоматом решать первый пост новичка».</li>
          </ul>
        </Notes>
      </Slide>

      {/* 7 — Кейс 1: MVP/архитектура */}
      <Slide>
        <Visual
          label={`БЛОК-СХЕМА MVP: Telegram (первое сообщение) → LLM\n(классификатор «спам?») → действие: бан/пропуск`}/>
        <Notes>
          <ul>
            <li>MVP собран за пару часов, ~500+ строк Python.</li>
            <li>Оценка по поведению: повёлся как надо — ship it.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 8 — Кейс 1: метрики/эффект */}
      <Slide>
        <TwoUp left={`ГРАФИК: «Баны по дням (12 мес)»\n[TODO: свести логи]`}
               right={`ИНФОГРАФИКА: «3–4 группы»\n«~9–10k банов/год»\n«ложных ~5–6»\n[TODO: перепроверить]`}/>
        <Notes>
          <ul>
            <li>Суммарно за год — порядка 9–10k банов, ложных — единицы (5–6). Кол-во групп — 3–4 (уточню).</li>
            <li>Эффект ощутимый, но история дальше — о том, как «магия» заставляет тянуть лишнее.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 9 — Кейс 1: перфекционизм vs MVP */}
      <Slide>
        <TwoUp left={`МЕМ/КОЛЛАЖ: «идеальный веб-логин»\n(форма, QR/SMS, красиво)`}
               right={`СКРИН-ЗАМЕТКА: «копировать session-файл и деплой»\n(простой путь)`}/>
        <Notes>
          <ul>
            <li>Я потратил дни, пытаясь выбить «идеальный UX логина» через LLM, вместо простого копирования сессии.</li>
            <li>Это классическая ловушка: совершенство вместо результата.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 10 — Кейс 1: раздувание скоупа */}
      <Slide>
        <Visual
          label={`ИНФОГРАФИКА: «утилита → продукт»\nЛедяная гора/айсберг: над водой — фичи, под водой — контекст, сущности, состояние`}/>
        <Notes>
          <ul>
            <li>Как только превращаешь утилиту в продукт — растёт контекст, LLM «забывает», управляемость падает.</li>
            <li>Побочный эффект — желание переписать на другом языке ещё раз.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 11 — Кейс 1: безопасность как поверхность атаки */}
      <Slide>
        <Visual
          label={`ДИАГРАММА «КЛЕТКА/РЕЦЕПТОРЫ»:\nЧем больше внешних входов/команд — тем выше риск.\nМалый скоуп API → меньше уязвимостей`}/>
        <Notes>
          <ul>
            <li>Безопасность: режем поверхность. Меньше «рецепторов» — меньше рисков.</li>
            <li>Для публичных сервисов работать «вслепую» нельзя — нужен ревью/тесты.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 12 — Вывод кейса 1 */}
      <Slide>
        <Visual label={`СТИКЕР: «Утилита — окей в чистом вайбе;\nПродукт — только с инженерной дисциплиной»`}/>
        <Notes>
          <ul>
            <li>Резюме: для одноразовой полезности вайб прекрасен; для продукта — легко скатиться в болото.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 13 — Кейс 2: «страшный» сервис */}
      <Slide>
        <Visual label={`КАРТА КОМПОНЕНТОВ: сервис метрик CI/CD\n(бэкенд, БД, вебхуки, алёрты) — как «чёрный ящик»`}/>
        <Notes>
          <ul>
            <li>Большой сервис метрик: трогать страшно, ломать нельзя.</li>
            <li>Стратегия: сначала страх «снять» снапшотами.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 14 — Кейс 2: снапшот-тесты */}
      <Slide>
        <Visual
          label={`PIPELINE-СХЕМА: Webhooks → Service (black box) → DB\n→ Snapshot (golden state) → Тесты сверяют отклонения`}/>
        <Notes>
          <ul>
            <li>Ставим сервис как чёрный ящик, подаём реальные события, фиксируем «золотое» состояние БД.</li>
            <li>Дальнейшие правки видны как дифы снапшотов.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 15 — Кейс 2: вклад LLM */}
      <Slide>
        <Visual
          label={`ПЛЕЙСХОЛДЕР СКРИНА: «Тестовый хелпер/обвязка, сгенерённая LLM»\n(без реального кода, просто мок-скрин)`}/>
        <Notes>
          <ul>
            <li>LLM сгенерила каркас: подъем окружения, загрузка фикстур, сравнение снапшотов. 2–3 итерации.</li>
            <li>Экономия времени vs ручной бойлерплейт.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 16 — Кейс 2: узкое место — отбор данных */}
      <Slide>
        <Visual
          label={`ВИЗУАЛ: «куча вебхуков» → «группы по PR/статусу/времени»\nТребование: быстро собирать датасеты для тестов`}/>
        <Notes>
          <ul>
            <li>Нужно быстро фильтровать/группировать события для разных тест-кейсов — вручную боль.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 17 — Кейс 2: локальная GUI-утилита */}
      <Slide>
        <Visual
          label={`МОК-СКРИН ПРИЛОЖЕНИЯ: «Webhook Explorer»\nФильтры/чекбоксы, группировка, Export\n~800 строк, Gemini 1.5 Pro [TODO: уточнить]`}/>
        <Notes>
          <ul>
            <li>За 5–20 минут vibecoded локальный GUI-инструмент: фильтры, группировка, экспорт наборов.</li>
            <li>Локально, без секретов — риски минимальны, ценность мгновенная.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 18 — Почему идеальный кейс для вайба */}
      <Slide>
        <ThreeUp a={`ИКОНКА: Локально`} b={`ИКОНКА: Одноразово / короткий горизонт`}
                 c={`ИКОНКА: Быстро / 2–3 итерации`}/>
        <Notes>
          <ul>
            <li>Локально, одноразово, быстро — там вайб раскрывается максимально.</li>
            <li>Не требуется эволюция: нет долговременной поддержки.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 19 — Подходы: Chat ↔ IDE цикл */}
      <Slide>
        <Visual label={`ДИАГРАММА: Chat ⇄ IDE ⇄ Runtime\n(копирую код/ошибки → итерации)`}/>
        <Notes>
          <ul>
            <li>Базовый цикл: сгенерил → вставил → запустил → вернул ошибки.</li>
            <li>Хорош для малых задач и изолированных модулей.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 20 — Подходы: Агенты */}
      <Slide>
        <TwoUp left={`СКРИН МЕСТА ДЛЯ АГЕНТА: Cursor/Aider UI (заглушка)`}
               right={`СХЕМА: Агент читает файлы → делает изменения → предлагает дифы`}/>
        <Notes>
          <ul>
            <li>Агентный кодинг часто путают с вайбом. Разница: вайб — это когда ты предлагаемые изменения почти не
              читаешь.
            </li>
            <li>Агент — инструмент; вайб — режим использования.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 21 — Подходы: Гибрид с большим контекстом */}
      <Slide>
        <Visual
          label={`PIPELINE: Большая LLM (большой контекст) читает проект →\nПлан/патчи → Агент применяет → Критические места ревью руками`}/>
        <Notes>
          <ul>
            <li>Гибрид: большая модель строит план и крупные правки, агент применяет, ты ревьюишь критические точки.
            </li>
          </ul>
        </Notes>
      </Slide>

      {/* 22 — Патчи ломаются: find/replace */}
      <Slide>
        <TwoUp left={`ИЛЛЮСТРАЦИЯ: unified diff с «плавающими» номерами строк`}
               right={`СХЕМА: правила find/replace / эвристическое применение патча агентом`}/>
        <Notes>
          <ul>
            <li>LLM плохо «считает» большие дифы. Выход: эвристики применения и/или описывать изменения как
              find/replace.
            </li>
          </ul>
        </Notes>
      </Slide>

      {/* 23 — Навигация по неизвестной кодовой базе */}
      <Slide>
        <Visual label={`СКРИН-МОК: «heatmap» поиска по проекту агентом\n(быстрый переход к нужной ручке/модулю)`}/>
        <Notes>
          <ul>
            <li>Ещё сильная сторона агентов — навигация в незнакомом проекте: быстро найти точки интереса.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 24 — Ловушка: перфекционизм */}
      <Slide>
        <Visual label={`МИНИ-МЕМ: «pixel-perfect login» vs «works/ship»`}/>
        <Notes>
          <ul>
            <li>Перфекционизм задерживает релиз. Правило: вначале полезность, потом красота.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 25 — Ловушка: иллюзия магии */}
      <Slide>
        <Visual label={`МЕМ: «волшебная палочка»\nПодпорка: «LLM ≠ бесконечный оркестр без дирижёра»`}/>
        <Notes>
          <ul>
            <li>Иллюзия всесилия раздувает цели: хочется «всё и сразу» — контекст разваливается.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 26 — Ловушка: sunk cost */}
      <Slide>
        <Visual label={`МЕМ «Вагонетка & невозвратные затраты»\n(остановить можно всегда, жертвы не «зря»)`}/>
        <Notes>
          <ul>
            <li>Чем больше итераций, тем сложнее бросить. Ставь стоп-правила заранее.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 27 — Ловушка: качество без экспертизы */}
      <Slide>
        <Visual
          label={`ИКОНКИ: «лупа по коду», «тесты»\nМетафора: «проверка глазами обязательна на критических путях»`}/>
        <Notes>
          <ul>
            <li>Без навыка ревью легко пропустить чушь. Минимальные тесты и просмотр критических дифов — must.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 28 — Ловушка: безопасность */}
      <Slide>
        <Visual label={`ИНФОГРАФИКА: PII/секреты/внешние входы\nМаркер: «по умолчанию — локально, без сетей»`}/>
        <Notes>
          <ul>
            <li>Не вайбкодим там, где PII/комплаенс/публичный контур без экспертизы и ревью.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 29 — Ловушка: масштаб */}
      <Slide>
        <Visual label={`ГРАФИК: «размер проекта ↑ → качество следования плану LLM ↓»`}/>
        <Notes>
          <ul>
            <li>Рост проекта → модель теряет детали. Переходи к гибриду/плану/ручному управлению.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 30 — Контрмера: Правило MVP */}
      <Slide>
        <Visual label={`ЧЕК-СТИКЕР: «Ship ugly MVP → итерации после релиза»\nПример: сессия-файл вместо веб-логина`}/>
        <Notes>
          <ul>
            <li>Первым делом — полезность. Фичи довозим позже.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 31 — Контрмера: Stop-rule */}
      <Slide>
        <Visual label={`ТАЙМЕР/СЧЁТЧИК: «N итераций или 30 минут → смена инструмента/ручками»`}/>
        <Notes>
          <ul>
            <li>Ставь границу заранее, чтобы не «вариться» в бесконечных промптах.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 32 — Контрмера: Минимальные тесты + чтение ключевых мест */}
      <Slide>
        <TwoUp left={`СХЕМА: Snapshot/Smoke тесты на границах`}
               right={`ИКОНКА: Чтение критических участков кода/дифов`}/>
        <Notes>
          <ul>
            <li>Всегда — быстрые смоуки/снапшоты, плюс глазами смотрю высокорисковые места.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 33 — Контрмера: Безопасность по умолчанию */}
      <Slide>
        <Visual label={`ПЛАКАТ: «Local-first, no secrets in prompts, minimize inputs»`}/>
        <Notes>
          <ul>
            <li>По умолчанию — локально; секреты не тащим в промпты; минимизируем внешние входы.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 34 — Контрмера: Разделяй продукт и одноразовую утилиту */}
      <Slide>
        <Visual label={`РАЗДЕЛИТЕЛЬ: «Продукт» ≠ «Одноразовый инструмент»\nДве дорожки развития`}/>
        <Notes>
          <ul>
            <li>Продукт требует архитектуры/поддержки; одноразовый инструмент — скоуп узкий, можно вайбить.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 35 — Контрмера: Матрица выбора режима */}
      <Slide>
        <Visual
          label={`МАТРИЦА: «масштаб задачи × риск/данные × срок жизни»\nЗоны: Чистый вайб / Гибрид / Классика+подсказки`}/>
        <Notes>
          <ul>
            <li>Выбираю режим по трём осям. Чистый вайб — одноразки и локальные вещи; гибрид — средние; классика —
              ядро.
            </li>
          </ul>
        </Notes>
      </Slide>

      {/* 36 — Философия из видео: инструмент хуже тебя, но больше тебя */}
      <Slide>
        <Visual label={`ВЕСЫ: «СКИЛЛ» vs «ПОКРЫТИЕ»\nНадпись-маркер: «Инструмент хуже тебя, но больше тебя»`}/>
        <Notes>
          <ul>
            <li>Если инструмент лучше тебя на участке — это сигнал учиться, а не делегировать.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 37 — Left-pad vs Vibe */}
      <Slide>
        <TwoUp left={`ИКОНКА: «зависимость/пакет» (left-pad метафора)`}
               right={`ИКОНКА: «локально сгенерённый кусок» (правится внутри проекта)`}/>
        <Notes>
          <ul>
            <li>Нельзя одновременно ругать зависимости и вайб: свой автоген проще править, чем чужую либу.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 38 — Legacy/throwaway code */}
      <Slide>
        <Visual
          label={`СХЕМА: «Legacy code skip»\nВайб-код как код, который быстро забывается/выбрасывается, но сделал дело ровно сейчас`}/>
        <Notes>
          <ul>
            <li>Большая часть кода — расходник. Вайб помогает быстро его создавать не влюбляясь.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 39 — График удовольствия/эффективности */}
      <Slide>
        <Visual
          label={`ГРАФИК: X — размер/сложность проекта; Y1 — эффективность вайба; Y2 — удовольствие разработчика\nОбе кривые падают с ростом X`}/>
        <Notes>
          <ul>
            <li>Чем больше проект, тем меньше отдача от чистого вайба — вовремя переключайся в гибрид/классику.</li>
          </ul>
        </Notes>
      </Slide>

      {/* 40 — Финал + Q&A */}
      <Slide>
        <Visual
          label={`СТИКЕР-ЗАДАНИЕ: «Найдите у себя код-расходник, который можно навайбить завтра локально и безопасно»`}/>
        <Notes>
          <ul>
            <li>Вывод: делай из магии процесс — матрица выбора, стоп-правила, минимальные тесты, безопасность.</li>
            <li>Q&A: примеры у слушателей, где можно «навайбить» быстро и без риска.</li>
          </ul>
        </Notes>
      </Slide>
    </Deck>
  );
}
