// src/slides/Deck.tsx
import React from "react";
import {
  Box,
  CodePane,
  Deck,
  Heading,
  ListItem,
  Notes,
  Quote,
  Slide,
  Table,
  TableBody,
  TableCell,
  TableHeader,
  TableRow,
  Text,
  UnorderedList,
} from "spectacle";

// Tiny helpers
const Todo = ({children}: { children: React.ReactNode }) => (
  <span style={{
    padding: '.35rem .5rem',
    border: '2px dashed currentColor',
    borderRadius: '.5rem',
    fontSize: '.9rem',
    display: 'inline-block',
  }}>
    [TODO] {children}
  </span>
);

export default function DeckApp() {
  return (
    <Deck template={() => null}>
      <Slide>
        <Heading fontSize="h2">Вайбкодинг — блажь или благо?</Heading>
        <Text>От эйфории к зрелости: как превратить магию в инженерный процесс</Text>
        <Quote style={{opacity: .7, fontSize: '1.5rem'}}>
          Презентация тоже навайбкожена на bun + TS + Spectacle
        </Quote>
        <Notes>
          <p><b>Главный тезис:</b> Превращаем "магию" в контролируемый инженерный процесс.</p>
          <hr/>
          <p>Всем привет, меня зовут Илья. Я работаю developer productivity инженером, а также релиз-инженером — в общем, мастером на все руки в компании inDrive. В зоне моей ответственности наш релизный pipeline и всё, что с ним связано.</p>
          <p>На сегодняшнем докладе я хочу рассказать вам, как я пришёл в вайбкодинг, что это такое, и почему вам, возможно, тоже стоит посмотреть в эту сторону и подумать: «какая же это офигенная штука».</p>
          <p>И да, эта презентация тоже была сделана на вайбе.</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">План</Heading>
        <UnorderedList>
          <ListItem>Что такое вайбкодинг и где его границы</ListItem>
          <ListItem>Кейс 1: Антиспам бот</ListItem>
          <ListItem>Кейс 2: Webhook Explorer</ListItem>
          <ListItem>Ловушки и гигиена</ListItem>
          <ListItem>Инструменты</ListItem>
          <ListItem>Мой текущий подход</ListItem>
        </UnorderedList>
        <Notes>
          <ul>
            <li>Быстро пробегитесь по пунктам.</li>
            <li><b>Особенно отметьте раздел про инструменты</b> — это обещание аудитории, что будет конкретика.</li>
            <li>Сформулируйте главную цель доклада: "Сегодня мы разберемся, где вайбкодинг — это благо, а где — просто блажь, и как провести эту границу".</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Хук</Heading>
        <Text>За год мой антиспам-бот забанил ≈9 000 спамеров</Text>
        <Text><Todo>мини-график «баны по дням»</Todo></Text>
        <Notes>
          <p><b>(≈15-20 секунд)</b></p>
          <p><b>Цель:</b> Зацепить цифрами и сразу сместить фокус на ответственность, а не на "вау-эффект".</p>
          <hr/>
          <ul>
            <li>За год мой бот забанил почти 9000 спамеров. Это по 25-30 в день.</li>
            <li>Но важнее другое: процент ошибок — всего 5 или 6 случайных банов за всё время. Нейронка ошиблась, но это очень низкий показатель.</li>
            <li>Я считаю это отличным результатом. Но это не магия.</li>
          </ul>
          <p><b>Переход:</b> Так что же такое вайбкодинг, который позволил это сделать?</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">История термина «вайбкодинг»</Heading>
        <Text>Термин популяризован Андреем Карпаты (ex-OpenAI) в ноябре 2024 в твитте.</Text>
        <Text><Todo>вынести 1 строку-цитату и дату появления термина</Todo></Text>
        <Notes>
          <ul>
            <li>Термин появился в твиттере Андрея Карпаты, бывшего разработчика из OpenAI, где-то в ноябре 2024 года.</li>
            <li><b>Суть его определения:</b> ты пишешь агенту, что хочешь, получаешь результат, не вникая в код. А потом корректируешь его простыми командами вроде «подвинь кнопочку», опять же, не читая код. Программируешь "на вайбе".</li>
            <li>Многие действительно так и делают. Но мне такой "слепой" подход не очень нравится.</li>
            <li><b>Оставьте интригу:</b> Дальше в докладе я расскажу, почему, и как делать это контролируемо. Оставляю "хлебные крошки".</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Что такое «вайбкодинг»</Heading>
        <UnorderedList>
          <ListItem>Программируешь намерениями/правками «на человеческом», не вникая глубоко в сгенерированный
            код.</ListItem>
          <ListItem>Идея популяризована в сообществе в конце 2024.</ListItem>
        </UnorderedList>
        <Notes>
          <p>Дайте простое определение, как на слайде.</p>
          <p>Кратко обозначьте дуальность: с одной стороны — скорость и магия, с другой — потеря контроля.</p>
          <p><b>Переход:</b> Мой первый настоящий опыт вайбкодинга случился в октябре 2024, почти год назад. Давайте посмотрим на плюсы и минусы на живом примере.</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Плюсы вайбкодинга</Heading>
        <UnorderedList>
          <ListItem>Скорость разработки</ListItem>
          <ListItem>Низкий порог входа</ListItem>
          <ListItem>«Дешёвые» одноразовые утилиты</ListItem>
          <ListItem>Приложения по запросу</ListItem>
        </UnorderedList>
        <Notes>
          <ul>
            <li><b>Скорость и простота</b> — главные козыри.</li>
            <li>Мы уже в эре "приложений по запросу", по крайней мере для разработчиков. Нам проще отдебажить, привести в нужный вид.</li>
            <li>Вайбкодинг позволяет быстро создавать утилиты, даже не вникая глубоко в доменную область.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Минусы вайбкодинга</Heading>
        <UnorderedList>
          <ListItem>Контроль качества</ListItem>
          <ListItem>Безопасность</ListItem>
          <ListItem>Масштабирование</ListItem>
          <ListItem>Иллюзия контроля</ListItem>
        </UnorderedList>
        <Notes>
          <p>Но на самом деле, есть огромное количество подводных камней.</p>
          <ul>
            <li>Работает не всегда так, как ты хочешь.</li>
            <li>И не всегда быстрее, чем сделать ручками.</li>
            <li><b>Главная ловушка:</b> легко попасть в цикл, когда ты часами пытаешься "добить" нейронку, хотя проще было бы написать самому. Нужно уметь себя останавливать.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Кейс 1: контекст</Heading>
        <UnorderedList>
          <ListItem><b>Задача:</b> антиспам в нескольких TG-группах (≈1–4k участников).</ListItem>
          <ListItem><b>Идея:</b> каждое сообщение новичка → LLM-классификация → бан/пропуск.</ListItem>
          <ListItem><b>MVP:</b> на вайбе за ~1–2 часа.</ListItem>
        </UnorderedList>
        <Notes>
          <p><b>Акцент:</b> Простота MVP и быстрый результат.</p>
          <hr/>
          <p>Мой первый настоящий "вау-эффект" от вайбкодинга. Я понял, что это не игрушка, а реальный инструмент.</p>
          <ul>
            <li><b>Проблема:</b> Несколько телеграм-групп, где я админ, и меня замучили спам-боты. Банить их вручную надоело.</li>
            <li><b>Идея:</b> Сделать телеграм-бота, который каждое сообщение нового юзера отправляет в LLM и классифицирует: спам или не спам.</li>
            <li><b>Результат:</b> Первая версия бота была написана где-то за час. И она до сих пор работает почти без изменений! Администрирует 4 группы от 1000 до 4000 человек.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Кейс 1: результаты</Heading>
        <UnorderedList>
          <ListItem>≈9 000 банов/год; 5–6 ложных — низкий FP.</ListItem>
          <ListItem>Работает без активной поддержки; редкие правки.</ListItem>
        </UnorderedList>
        <Text><Todo>Мини-график/скрин обзора метрик</Todo></Text>
        <Notes>
          <p><b>(≈30 секунд)</b></p>
          <p>Это та самая красивая история, которую вы постоянно видите в Твиттере: <i>«Ребята, я заменил всю команду нейронками, и мой продукт зарабатывает миллион баксов! Разработчики не нужны!»</i></p>
          <p>Цифры на слайде подтверждают — всё круто.</p>
          <p><b>Переход:</b> Но это только одна сторона медали. А теперь о том, где "чистый вайб" меня подвёл.</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Где подвёл «чистый вайб»</Heading>
        <UnorderedList>
          <ListItem><b>Перфекционизм:</b> хотел идеальный login UI и «Python-first» → TS → Rust → Kotlin → обратно
            Python.</ListItem>
          <ListItem><b>Sunk cost:</b> «ещё одна итерация в агенте» — часы ушли, пользы мало.</ListItem>
          <ListItem><b>Не читаю код:</b> риск уязвимостей в публичном сервисе.</ListItem>
          <ListItem><b>Инструментальная ловушка:</b> «делаю только агентом» → тупики на интеграции.</ListItem>
        </UnorderedList>
        <Notes>
          <p><b>Здесь важна самоирония.</b> Расскажите историю о том, как MVP за 2 часа превратился в многодневную борьбу.</p>
          <ul>
            <li>Да, работающая версия была написана быстро. Но потом я потратил несколько дней, пытаясь довести её до "идеала" в моей голове.</li>
            <li>Началась эпопея переписываний: с Python на TypeScript, потом на Rust, на Kotlin, и обратно на Python. Каждый раз — головная боль.</li>
            <li><b>Ключевая ошибка:</b> я решил быть "трушным" вайбкодером и не писать код руками, только командовать агентом. <b>Это путь в никуда</b>, если вы хотите сделать рабочий продукт, а не просто поделку на коленке.</li>
            <li>Для простых задач — да, вайбкодинг — ваше всё. Для чего-то сложнее — нужны более комплексные, инженерные подходы.</li>
            <li>В итоге, пока я страдал, вышел LOLZ Anti-Spam бот, который захватил весь ру-телеграм. Ребята, видимо, кодили и руками тоже, потому что такой функционал на чистом вайбе не сделать.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Кейс 1: перфекционизм в деталях</Heading>
        <UnorderedList>
          <ListItem>Хотел веб-логин UI на Python-first фреймворках</ListItem>
          <ListItem>Переписывал языки из-за идеальной картины</ListItem>
          <ListItem>В итоге: простая сессия без UI</ListItem>
        </UnorderedList>
        <Notes>
          <p><b>Конкретный пример, как перфекционизм + вайб = ад.</b></p>
          <ul>
            <li>Мой бот — это user-bot, он симулирует пользователя. Ему нужна аутентификация: ввести номер телефона, получить SMS. Это не просто токен вставить.</li>
            <li><b>Правильное, простое решение:</b> залогиниться один раз локально, скопировать файл сессии на сервер. Всё.</li>
            <li><b>Моё перфекционистское решение:</b> Я захотел красивый веб-интерфейс для логина! Чтобы можно было зайти, ввести номер, отсканировать QR-код... Причём хотел, чтобы всё было на одном языке, например, "Python-first" фреймворки, которые сами генерят фронт.</li>
            <li>Я думал, так агенту будет проще работать. Но ни на Python, ни на TypeScript, ни на Rust ничего толком не заработало. Я принципиально не хотел писать руками.</li>
            <li><b>Итог:</b> Куча потраченного времени. В конце я просто откатился назад, скопировал файл, и всё заработало. У меня нет красивой логин-формы, но... <b>за год мне ни разу не пришлось перелогиниться.</b> Усилия были потрачены зря.</li>
            <li><b>Вывод:</b> Перфекционизм + вайбкодинг — это путь в ад.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Кейс 1: sunk cost в деталях</Heading>
        <UnorderedList>
          <ListItem>Пытался развить в продукт (подписки, группы)</ListItem>
          <ListItem>Переписывал 4-5 раз за год</ListItem>
          <ListItem>В итоге: MVP работает, развитие отложено</ListItem>
        </UnorderedList>
        <Notes>
          <p>Эпопея не закончилась. В течение года я 4-5 раз пытался переписать бота, превратить его в полноценный продукт.</p>
          <ul>
            <li><b>Идея:</b> Сделать так, чтобы любой мог добавить бота в свою группу, настроить лимиты, платить денежку за API нейронки.</li>
            <li>Я пробовал гибридные подходы: генерил план в Gemini, потом скармливал его агенту, чтобы тот написал новую версию на TypeScript.</li>
            <li><b>Проблема:</b> Как только проект разрастался, агент начинал терять контекст и писать ерунду.</li>
            <li>Я хотел, чтобы и тесты писались автоматически. Но тесты — это ещё тысячи строк кода, которые окончательно убивали контекст модели.</li>
            <li><b>Итог:</b> Я так и не переписал бота. Не хочу писать его руками, а чисто на вайбе такой проект не вытянуть без очень грамотного подхода.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Кейс 1: как правильно (гигиена)</Heading>
        <UnorderedList>
          <ListItem>Команды только от супер-админа/вайтлист ролей.</ListItem>
          <ListItem>Логин один раз локально → перенос сессии на сервер (без «красивого» UI).</ListItem>
          <ListItem>Логи и простые алерты (всплеск банов/ошибок).</ListItem>
        </UnorderedList>
        <Text style={{fontSize: '.9rem'}}><b>Стоп-критерии:</b> 2 фейла подряд → смена инструмента/урезать фичу;
          если <code>T_LLM &gt; T_manual</code> дважды — стоп.</Text>
        <Text style={{fontSize: '.9rem'}}><b>Итог:</b> «вайб» — для MVP; дальше — рамки и контроль.</Text>
        <Notes>
          <p>Как надо было делать и как в итоге работает:</p>
          <ul>
            <li><b>Сузить поверхность атаки:</b> Команды боту может отдавать только суперадмин. Это отсекает 99% проблем с безопасностью.</li>
            <li><b>Простое решение лучше сложного:</b> Логин через файл сессии, а не через навороченный UI.</li>
            <li><b>Наблюдаемость:</b> Простые логи и алерты, чтобы понимать, что происходит.</li>
            <li><b>Стоп-критерии:</b> Важно иметь правила, когда остановиться. Если агент дважды подряд не справляется — меняй подход. Если понимаешь, что руками быстрее — делай руками.</li>
          </ul>
          <p><b>Вывод:</b> Вайб — это круто для MVP, но дальше нужен контроль. Вайб не означает "без контроля".</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Кейс 2: боль и цель</Heading>
        <UnorderedList>
          <ListItem><b>Сервис:</b> сбор метрик CI/CD, тонна GitHub webhooks.</ListItem>
          <ListItem><b>Цель:</b> менять логику, не ломая старое; быстро собирать тестовые наборы из реальных
            событий.</ListItem>
        </UnorderedList>
        <Notes>
          <p>Следующий проект, где вау-эффект был ещё сильнее. Буквально за 5 минут я навайбкодил решение, которое сэкономило мне часы.</p>
          <ul>
            <li><b>Контекст:</b> У нас есть сервис, который собирает метрики с нашего CI/CD пайплайна. Он слушает вебхуки от GitHub.</li>
            <li>Вебхук — это когда GitHub сообщает нашему серверу о событиях: джоба началась, закончилась, упала и т.д. Информации очень много.</li>
            <li><b>Проблема:</b> Мне нужно было внести большие изменения в этот сервис (написанный не мной) и убедиться, что я ничего не сломал.</li>
          </ul>
          <p><b>Переход:</b> Как это сделать, не вникая в сложный код? Считать сервис "чёрным ящиком".</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Решение: «чёрный ящик» + снапшоты</Heading>
        <UnorderedList>
          <ListItem>Поднимаем сервис и БД; на вход — реальные вебхуки; на выходе — состояние БД → снапшотим.</ListItem>
          <ListItem>LLM генерит каркас тестового стенда.</ListItem>
          <ListItem>Валидируем: на одинаковом входе всегда одинаковый снимок.</ListItem>
        </UnorderedList>
        <Notes>
          <p>Здесь я использовал сразу две вайб-кодинг методики.</p>
          <ol>
            <li><b>Снэпшот-тесты.</b> Идея простая:
              <ul>
                <li>Считаем сервис "чёрным ящиком".</li>
                <li>Подаём на вход пачку реальных вебхуков.</li>
                <li>Сервис что-то записывает в базу данных.</li>
                <li>Мы сохраняем это состояние базы (делаем "снэпшот").</li>
                <li>Теперь наш тест проверяет: если подать тот же самый вход, на выходе должен получиться тот же самый снэпшот. Если нет — значит, что-то сломалось.</li>
              </ul>
            </li>
            <li><b>LLM для генерации обвязки.</b> Я скормил нейронке код сервиса и попросил: <i>"напиши мне тестовый фреймворк для снэпшот-тестирования"</i>. Она сгенерила всю обвязку, я даже не вникал в детали.</li>
          </ol>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Webhook Explorer (утилита «по запросу»)</Heading>
        <UnorderedList>
          <ListItem>За 5–20 минут LLM сгенерила GUI на Python: фильтр по PR/статусу/времени, сбор групп событий, экспорт
            кейсов.</ListItem>
          <ListItem>«Руками» заняло бы ≈3 часа.</ListItem>
        </UnorderedList>
        <Text><Todo>Скриншот GUI; пояснить поля фильтров</Todo></Text>
        <Notes>
          <p>Но была проблема: мне нужны были разные наборы данных для тестов. Например, пачка вебхуков для успешной джобы, пачка для упавшей.</p>
          <p>Перебирать тысячи JSON-файлов руками — это ад. На одну джобу может прилететь 40 событий.</p>
          <p>И тут я применил вайбкодинг как ниндзя:</p>
          <ul>
            <li>Я скачал все вебхуки за последние 3 дня.</li>
            <li>Показал нейронке пару примеров и сказал: <i>«Напиши мне графическую программу на Питоне, которая читает папку с вебхуками, позволяет их фильтровать по номеру PR, статусу, времени, группировать, а потом экспортировать выбранные группы».</i></li>
            <li><b>За 5 минут нейронка сгенерировала готовую программу на 800 строк, которую я бы руками писал часа три, если не больше.</b></li>
            <li>С этой утилитой я просто накликал нужные мне тест-кейсы и экспортировал их.</li>
          </ul>
          <p><b>Ключевая мысль:</b> <i>Раньше я бы такую утилиту даже не стал писать</i>, это было бы бессмысленно дорого по времени. С нейронками это занимает 20 минут с доработками. Это и есть "приложения по запросу".</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">ROI и ловушки</Heading>
        <UnorderedList>
          <ListItem><b>ROI:</b> 3 часа → ≈20 минут (генерация + фиксы).</ListItem>
          <ListItem><b>Валидация:</b> «сгенерилось» ≠ «надёжно» → минимум снапшотов (happy/fail).</ListItem>
          <ListItem><b>Данные:</b> не утащить секреты/PII в промпты/репо.</ListItem>
          <ListItem><b>Иллюзия контроля:</b> важнее корректно группировать вход/выход, а не «красота GUI».</ListItem>
        </UnorderedList>
        <Notes>
          <p>Это очень яркий пример, но и тут есть свои нюансы.</p>
          <ul>
            <li><b>ROI очевиден:</b> экономия времени колоссальная.</li>
            <li><b>Безопасность данных:</b> Важно следить, чтобы в промпты не утекли секреты или персональные данные.</li>
            <li><b>Приоритеты:</b> Главной задачей было получить корректные наборы данных. Красота GUI была на десятом месте. Важно не увлечься перфекционизмом.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Мини-сниппет снапшота</Heading>
        <div style={{fontSize: '.8rem', lineHeight: 1.2}}>
          <CodePane language="diff">
            {`
            - before: metrics.job_duration[pr=123, status=failed] = 00:00:00
            + after:  metrics.job_duration[pr=123, status=failed] = 00:07:42
            `}
          </CodePane>
        </div>
        <Text><Todo>Заменить на реальный короткий diff/фрагмент дампа БД (≤7 строк)</Todo></Text>
        <Notes>
          <p><b>(15 секунд)</b></p>
          <p>Просто чтобы показать принцип. Вот так выглядит снэпшот. Это просто текстовый файл, который фиксирует состояние системы. Если после наших изменений diff не пустой — значит, что-то пошло не так (или это ожидаемое изменение).</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Почему «чистый вайб» ломается</Heading>
        <UnorderedList>
          <ListItem>Контекст и патчи: модели путают номера строк → diff рвётся.</ListItem>
          <ListItem>Агенты: теряют рабочую директорию, пропускают файлы, зацикливаются.</ListItem>
          <ListItem>Языки: Python &gt; TypeScript &gt; … (по опыту 2024–2025).</ListItem>
          <ListItem>Перфекционизм + публичный периметр = рост риска уязвимостей.</ListItem>
          <ListItem>Sunk cost: «уже столько вложили…»</ListItem>
        </UnorderedList>
        <Notes>
          <p><b>(≈60 секунд)</b></p>
          <p>Давайте подытожим, почему подход "просто говори агенту, что делать" ломается на больших проектах.</p>
          <ul>
            <li><b>Проблема с патчами:</b> Модели плохо считают, поэтому часто ошибаются в номерах строк. В итоге патч не применяется.</li>
            <li><b>Проблемы агентов:</b> Они могут запутаться, в какой папке находятся, пропустить важные файлы при рефакторинге или просто зациклиться.</li>
            <li><b>Языки:</b> Мой опыт показывает, что Python генерируется лучше всего, потом TypeScript. С Kotlin, например, всё сложнее.</li>
            <li>И две ловушки, о которых мы уже говорили: <b>перфекционизм</b> и <b>ошибка невозвратных затрат</b>.</li>
          </ul>
          <p><b>Идея для графика:</b> С ростом размера проекта эффективность чистого вайбкодинга падает, и удовольствие разработчика тоже падает.</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Ловушка: перфекционизм</Heading>
        <UnorderedList>
          <ListItem>Погони за «идеальным стеком»</ListItem>
          <ListItem>Переписывания без пользы</ListItem>
          <ListItem>Сочетание с вайбом — ад</ListItem>
        </UnorderedList>
        <Notes>
          <p>Мы уже разобрали это на примере бота. Главная мысль: погоня за идеальной архитектурой или UI в проекте, который этого не требует, — это прямой путь к потраченному времени. Особенно в сочетании с вайбкодингом.</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Ловушка: sunk cost</Heading>
        <UnorderedList>
          <ListItem>Ошибка невозвратных затрат</ListItem>
          <ListItem>Мем про вагонетку: остановить можно сейчас</ListItem>
          <ListItem>2 фейла — смена подхода</ListItem>
        </UnorderedList>
        <Notes>
          <p>Это когнитивное искажение, когда мы не можем бросить что-то, потому что "уже столько сил вложено".</p>
          <p>Есть мем про вагонетку: "Если остановить её сейчас, то те, кто уже умер, умерли зря". Это оно.</p>
          <p>Бороться с этим сложно, я и сам всё ещё борюсь. Главное — осознавать эту ловушку и иметь чёткие стоп-критерии, например, "два фейла подряд — меняем подход".</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Ловушка: безопасность</Heading>
        <UnorderedList>
          <ListItem>Не вникая — риски уязвимостей</ListItem>
          <ListItem>Для публичных сервисов — ревью обязательно</ListItem>
          <ListItem>Сужение поверхности атаки</ListItem>
        </UnorderedList>
        <Notes>
          <p>Это, пожалуй, самая большая проблема для публичных сервисов.</p>
          <ul>
            <li>Если ты не смотришь в код, ты с большой вероятностью пропустишь очевидные уязвимости.</li>
            <li>Даже если смотришь, можешь пропустить, нужна экспертиза.</li>
            <li><b>Как с этим жить?</b> Сужать поверхность атаки. В моём боте есть супер-топорный механизм: если команду написал не я (или не админ группы) — идите лесом. Это отсекает большинство рисков.</li>
            <li>Если у вашего инструмента вообще нет внешнего взаимодействия, то и проблем с безопасностью, скорее всего, не будет.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Контрмеры к ловушкам</Heading>
        <UnorderedList>
          <ListItem>Делить патчи на файлы/малые MR.</ListItem>
          <ListItem>Для агентов: <code>/compact</code>, перезапуск, summary-файл прогресса.</ListItem>
          <ListItem>Выбирать язык, где модель сильнее, для одноразовых тулз.</ListItem>
          <ListItem>Мини-полиси безопасности и фича-флаги «off by default».</ListItem>
          <ListItem>Таймбоксы: ≤15 минут на микротулзу; 40 минут без прогресса → стоп.</ListItem>
        </UnorderedList>
        <Notes>
          <p>Практические советы, как не попадать в эти ловушки:</p>
          <ul>
            <li><b>Дробите задачи:</b> Просите агента делать изменения по одному файлу или небольшой фиче.</li>
            <li><b>Чините агента:</b> Если агент "поплыл", используйте команду <code>/compact</code>, чтобы сжать диалог, или просто перезапустите его с чистого листа.</li>
            <li><b>Выбирайте язык прагматично:</b> Для одноразовой утилиты берите Python, даже если вы его не любите. Модель справится лучше.</li>
            <li><b>Ставьте таймеры:</b> У меня есть правило: 15 минут на микро-утилиту. Если за 40 минут нет прогресса по большой задаче — стоп, нужно переформулировать.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Другие примеры вайба</Heading>
        <UnorderedList>
          <ListItem>Bash/YAML конфиги без ручного кода</ListItem>
          <ListItem>CI-проверки/линтеры-эвристики</ListItem>
          <ListItem>Красивые отчёты в PR</ListItem>
          <ListItem>Навигация в legacy-коде</ListItem>
        </UnorderedList>
        <Notes>
          <p>Вайбкодинг — это не только про приложения. Вот где я его использую каждый день:</p>
          <ul>
            <li><b>Bash и YAML:</b> Я DevOps, и я ненавижу Bash. Есть такое свойство: ты никогда не знаешь Bash, его каждый раз приходится гуглить. За последний год я не написал ни одной строчки на Bash руками — всё делала нейронка. То же самое с YAML-конфигами для CI.</li>
            <li><b>CI-проверки:</b> Нужно написать простой линтер, который проверяет код по какому-то правилу? Нейронка генерирует его за 3-4 минуты.</li>
            <li><b>Красивые отчёты:</b> Коллега сделал CI-проверку, но вывод был нечитаемым. Я за 10 минут с помощью нейронки сгенерил красивый отчёт в виде таблички, который постится в PR. Сам бы я поленился это делать.</li>
            <li><b>Навигация в legacy:</b> "Найди, какая ручка на бэкенде отдаёт фича-флаги". Агент прошерстил проект и нашёл. В незнакомой кодовой базе — это суперсила.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Инструменты под задачи — «лестница»</Heading>
        <UnorderedList>
          <ListItem><b>Уровень 1 — Чат LLM:</b> ChatGPT/Claude/Gemini/Grok и т.п.</ListItem>
          <ListItem><b>Уровень 1.5 — files-to-prompt/патчи:</b> формируем контекст из папок/файлов.</ListItem>
          <ListItem><b>Уровень 2 — Большой контекст:</b> план/ревью/патчи по всему проекту.</ListItem>
          <ListItem><b>Уровень 3 — Агенты:</b> Aider, Cursor/Kiro, Copilot Chat и т.п.</ListItem>
        </UnorderedList>
        <Notes>
          <p>Теперь давайте поговорим про инструменты и подходы. Их можно условно разделить на несколько уровней.</p>
          <ol>
            <li><b>Простой чат (ChatGPT, Gemini):</b> Копируешь код, получаешь ответ, вставляешь обратно. Работает для небольших кусков.</li>
            <li><b>Утилиты для контекста (files-to-prompt):</b> Помогают собрать все нужные файлы в один большой промпт. Удобно, но патчи часто ломаются из-за номеров строк.</li>
            <li><b>Большой контекст (Gemini 1.5 Pro):</b> Позволяет "запихнуть" в модель почти весь проект и попросить, например, составить план разработки.</li>
            <li><b>Агенты (Aider, Cursor):</b> Инструменты, которые могут сами читать файлы, применять изменения и работать в цикле. Они бывают как плагины к IDE, так и утилиты в командной строке.</li>
          </ol>
          <p>Дальше мы разберём каждый уровень подробнее.</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Уровень 1: Чат (+ files-to-prompt)</Heading>
        <UnorderedList>
          <ListItem><b>Когда:</b> маленькие задачи, отдельные файлы, короткие сниппеты, объяснения.</ListItem>
          <ListItem><b>Как:</b> «покормили» контентом, получили код/патч.</ListItem>
          <ListItem><b>Плюсы:</b> простота, скорость.</ListItem>
          <ListItem><b>Минусы:</b> ломается на больших diff (номера строк), легко потерять целостность.</ListItem>
          <ListItem><b>Шаблоны промптов:</b> «Дай патч для X», «Объясни файл Y в 5 пунктах», «Сделай минимальный пример
            для Z».</ListItem>
        </UnorderedList>
        <Notes>
          <p><b>(≈40 секунд)</b></p>
          <p>Это базовый уровень, с которого все начинают. Идеально для изолированных задач.</p>
          <ul>
            <li>"Объясни мне этот кусок кода".</li>
            <li>"Напиши функцию, которая делает то-то".</li>
            <li>С помощью утилит типа `files-to-prompt` можно собрать контекст из нескольких файлов и попросить сгенерировать патч.</li>
            <li><b>Проблема:</b> как только файлов становится много, патчи начинают ломаться из-за неверных номеров строк.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Уровень 2: Большой контекст</Heading>
        <UnorderedList>
          <ListItem><b>Когда:</b> нужно «прочитать» проект, составить <b>план из ≤7 шагов</b>, сделать
            обзор/диагностику.</ListItem>
          <ListItem><b>Плюсы:</b> видит много, умеет планировать изменения.</ListItem>
          <ListItem><b>Минусы:</b> не всегда идеально «считает» патчи; нужна валидация.</ListItem>
          <ListItem><b>Шаблоны:</b> «Сделай план имплементации X с критериями готовности», «Найди, где фича-флаги
            отдаются на бэкенде».</ListItem>
        </UnorderedList>
        <Notes>
          <p>С появлением моделей с огромным контекстом (как Gemini 1.5 Pro) открылись новые возможности.</p>
          <ul>
            <li>Теперь можно "скормить" модели весь проект и попросить не код, а <b>план разработки</b>. Например: "Составь план из 5-7 шагов для добавления фичи X, с критериями готовности для каждого шага".</li>
            <li>Это отлично работает для навигации в коде. "Где в этом проекте происходит работа с фича-флагами?"</li>
            <li>Этот план потом можно выполнять пошагово, в том числе с помощью агента.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Уровень 3: Агенты (CLI/IDE)</Heading>
        <UnorderedList>
          <ListItem><b>Когда:</b> применять план пошагово, навигация, мелкие рефакторы, генерация/правки по
            месту.</ListItem>
          <ListItem><b>Плюсы:</b> скорость, меньше копипасты, может сам применять изменения.</ListItem>
          <ListItem><b>Минусы/анти-паттерны:</b> зацикливание, неверная директория, пропуск файлов, чрезмерная
            автономность без валидации.</ListItem>
          <ListItem><b>Repair-приёмы:</b> <code>/compact</code>, перезапуск, «один шаг плана за раз», фиксировать
            «сделано» в файле.</ListItem>
        </UnorderedList>
        <Notes>
          <p><b>(≈60-70 секунд)</b></p>
          <p>Агенты — это следующий шаг. Они автоматизируют рутину.</p>
          <p><b>Когда их использовать?</b></p>
          <ul>
            <li>Для выполнения шагов из плана, который мы получили на предыдущем уровне.</li>
            <li>Для мелких рефакторингов по всему проекту.</li>
            <li>Для создания новых проектов с нуля, если они не очень большие.</li>
          </ul>
          <p><b>Но у них есть типичные проблемы:</b></p>
          <ul>
            <li><b>Зацикливание:</b> Агент пытается выполнить команду, у него не получается, и он начинает перебирать варианты по кругу.</li>
            <li><b>Потеря контекста:</b> Забывает, в какой папке находится, или пропускает файлы.</li>
          </ul>
          <p><b>Как это чинить?</b></p>
          <ul>
            <li><b>/compact:</b> Команда, которая "сжимает" историю диалога, чтобы освободить контекст.</li>
            <li><b>Перезапуск:</b> Иногда проще начать заново.</li>
            <li><b>Один шаг за раз:</b> Не давайте агенту слишком общую задачу. Лучше "выполни пункт 1 из плана".</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Матрица выбора инструмента (Task × Tool)</Heading>
        <Table>
          <TableHeader>
            <TableRow>
              <TableCell>Задача</TableCell>
              <TableCell>Чат</TableCell>
              <TableCell>files-to-prompt</TableCell>
              <TableCell>Большой контекст</TableCell>
              <TableCell>Агент</TableCell>
              <TableCell>Гибрид</TableCell>
            </TableRow>
          </TableHeader>
          <TableBody>
            {([
              ["Микро-утилита (одноразовая)", "✔︎", "✔︎", "", "", ""],
              ["Небольшой рефактор/фиксы", "✔︎", "✔︎", "", "✔︎", "✔︎"],
              ["Навигация в незнакомом проекте", "", "", "✔︎", "✔︎", "✔︎"],
              ["CI-проверки/линтеры-эвристики", "✔︎", "✔︎", "", "✔︎", ""],
              ["Генерация конфигов (YAML/Bash)", "✔︎", "✔︎", "", "", ""],
              ["Публичный сервис/интеграции", "", "", "✔︎ (план/ревью)", "", "✔︎"],
              ["Тестовый стенд/снапшоты", "", "", "✔︎", "✔︎", "✔︎"],
            ] as const).map((row, i) => (
              <TableRow key={i}>
                {row.map((cell, j) => <TableCell key={j}>{cell}</TableCell>)}
              </TableRow>
            ))}
          </TableBody>
        </Table>
        <Notes>
          <p>Чтобы было проще, вот небольшая шпаргалка. Галочка означает "хороший базовый выбор" для задачи.</p>
          <ul>
            <li><b>Пример 1:</b> Нужно написать одноразовый скрипт на 50 строк? Обычного чата более чем достаточно.</li>
            <li><b>Пример 2:</b> Нужно добавить новую фичу в большой публичный сервис? Лучше использовать гибридный подход: сначала получить план с помощью большого контекста, а потом реализовывать его с помощью агента, постоянно проверяя результат.</li>
          </ul>
          <p>Эта таблица — не догма, а скорее ориентир.</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Сигналы переключить инструмент</Heading>
        <UnorderedList>
          <ListItem>Патч рвётся по строкам → к большому контексту/гибриду.</ListItem>
          <ListItem>Агент буксует 2 итерации → compact/перезапуск/гибрид.</ListItem>
          <ListItem>Контекст раздулся → делим задачи, суммаризируем диалог.</ListItem>
          <ListItem>Время LLM стабильно &gt; ручного → остановка/урезание фичи.</ListItem>
        </UnorderedList>
        <Notes>
          <p>Важно не упираться в один инструмент. Вот "дорожные знаки", которые говорят, что пора что-то менять.</p>
          <ul>
            <li>Если чат постоянно выдаёт битые патчи — значит, задача для него слишком сложная, пора переходить к агенту или гибридному методу.</li>
            <li>Если агент два раза подряд не справляется с задачей — остановитесь. Сделайте `/compact`, перезапустите или разбейте задачу на более мелкие.</li>
            <li>И главный сигнал: если вы понимаете, что уже потратили на уговоры нейронки больше времени, чем ушло бы на написание кода руками, — останавливайтесь.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Языки и ожидания</Heading>
        <UnorderedList>
          <ListItem><b>По опыту:</b> Python &gt; TypeScript &gt; … &gt; Kotlin (прогресс есть, но всё ещё сложнее, чем
            Py/TS).</ListItem>
          <ListItem><b>Следствие:</b> для утилит не стесняйся выбирать язык, где модель сильнее.</ListItem>
          <ListItem style={{fontSize: '.85rem'}}><b>Дисклеймер:</b> эмпирика за 2024–2025, не истина в последней
            инстанции.</ListItem>
        </UnorderedList>
        <Notes>
          <p><b>(≈30 секунд)</b></p>
          <p>Небольшое наблюдение из личного опыта.</p>
          <ul>
            <li>Модели обучаются на огромном количестве кода из интернета. Больше всего там Python, поэтому на нём они генерят лучше всего.</li>
            <li>На втором месте, по моим ощущениям, TypeScript/JavaScript.</li>
            <li>С более нишевыми или сложными языками, вроде Kotlin, всё немного хуже. Прогресс есть, но до уровня Python ещё далеко.</li>
            <li><b>Прагматичный вывод:</b> если вы пишете одноразовую утилиту для себя, не стесняйтесь выбрать Python, даже если основной ваш язык другой. Результат будет быстрее и качественнее.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Безопасность: минимум для маленьких ботов</Heading>
        <UnorderedList>
          <ListItem>Сужаем поверхность: только админ-команды/вайтлист.</ListItem>
          <ListItem>Секреты не в коде: env/secret manager.</ListItem>
          <ListItem>Пинить версии зависимостей; избегать «левых» пакетов.</ListItem>
          <ListItem>Логи/алерты (ошибки, аномальные баны, rate limit).</ListItem>
          <ListItem>Инпут-валидация даже «для своих».</ListItem>
        </UnorderedList>
        <Notes>
          <p>Этот слайд — как памятка, которую можно сфотографировать. Базовый чек-лист по безопасности, особенно если ваш "навайбленный" проект смотрит в интернет.</p>
          <ul>
            <li><b>Главное правило:</b> сужайте поверхность атаки. Чем меньше людей и систем могут взаимодействовать с вашим кодом, тем лучше.</li>
            <li>Не храните секреты в коде.</li>
            <li>Фиксируйте версии зависимостей.</li>
            <li>Имейте хотя бы минимальные логи и алерты, чтобы понимать, если что-то пошло не так.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Гибридный метод: План → Агент → Тесты</Heading>
        <UnorderedList>
          <ListItem>Большой контекст LLM делает план (≤7 шагов, критерии готовности, риски).</ListItem>
          <ListItem>Агент выполняет <b>один шаг</b>; фиксируем «сделано» в файле.</ListItem>
          <ListItem>После каждого шага — тест/снапшот.</ListItem>
          <ListItem>Застряли → compact/перезапуск/уточнение плана.</ListItem>
          <ListItem>Релиз → метрики/алерты.</ListItem>
        </UnorderedList>
        <Text style={{fontSize: '.9rem'}}>
          <b>Шаблон промпта «Сделай план»:</b> Цель; Ограничения; Критерии готовности; Риски; 5–7 шагов; проверка после
          каждого.
        </Text>
        <Notes>
          <p>Это самый зрелый и контролируемый подход, который у меня работает для сложных задач.</p>
          <ol>
            <li><b>Планирование:</b> Скармливаем весь проект в модель с большим контекстом (Gemini) и просим составить детальный план из 5-7 шагов. С критериями готовности! Например: <i>"Критерий готовности для шага 2: написан юнит-тест для нового сервиса, и он проходит".</i></li>
            <li><b>Исполнение:</b> Берём агента (Aider) и даём ему команду выполнить <b>только один шаг</b> из плана.</li>
            <li><b>Верификация:</b> После выполнения шага запускаем тесты или проверяем снэпшот. Убеждаемся, что всё в порядке.</li>
            <li><b>Повторение:</b> Если всё ок, переходим к следующему шагу. Если агент застрял — чиним его и пробуем снова.</li>
          </ol>
          <p>Это уже не "магия", а настоящий инженерный процесс с использованием AI.</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Рецепт snapshot-тестов «чёрного ящика»</Heading>
        <UnorderedList>
          <ListItem>Собрать реальные вебхуки за короткий период.</ListItem>
          <ListItem>Поднять сервис + БД локально/в тест-контейнере.</ListItem>
          <ListItem>Прогнать наборы вебхуков → зафиксировать состояние БД в файлы.</ListItem>
          <ListItem>При изменениях — прогонять снова; diff ≠ 0 → разбираться.</ListItem>
          <ListItem>Минимум 2 набора: happy-path и fail-path.</ListItem>
        </UnorderedList>
        <Notes>
          <p>Короткий рецепт, как реализовать подход из второго кейса.</p>
          <ul>
            <li><b>Используйте реальные данные:</b> Это ключ к успеху. Соберите настоящие события, на которых работает ваш сервис.</li>
            <li><b>Изолируйте окружение:</b> Поднимайте сервис и его базу данных в докер-контейнерах, чтобы тесты были повторяемыми.</li>
            <li><b>Фиксируйте результат:</b> Сохраняйте состояние БД (или любой другой выход системы) в простые текстовые файлы.</li>
            <li><b>Проверяйте и happy, и fail path:</b> Убедитесь, что у вас есть тест-кейсы как для успешного выполнения, так и для ошибок.</li>
            <li><b>Вспомните про Webhook Explorer:</b> Именно для сбора этих наборов данных и была создана та утилита.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Таймбоксы и anti-sunk cost</Heading>
        <UnorderedList>
          <ListItem>Микро-тулза: ≤15 мин (или бросаем/упрощаем).</ListItem>
          <ListItem>2 подряд провальные итерации с агентом → меняем инструмент.</ListItem>
          <ListItem>40 мин без прогресса → стоп/переформулировать.</ListItem>
          <ListItem>Мем про вагонетку: «остановить можно сейчас — иначе прошлые жертвы окажутся зря».</ListItem>
        </UnorderedList>
        <Notes>
          <p>Ещё раз, коротко и с улыбкой, про то, как не тратить время зря.</p>
          <ul>
            <li>Установите себе личные лимиты времени.</li>
            <li>Два фейла подряд — это сигнал, что нужно что-то менять.</li>
            <li>Запомните мем про вагонетку. Иногда лучшее решение — это просто остановиться.</li>
          </ul>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Размер проекта vs эффективность вайба</Heading>
        <Text>Линия 1: <b>Эффективность чистого вайбкодинга</b> ↓ с ростом размера.</Text>
        <Text>Линия 2: <b>Удовольствие разработчика</b> ↓ после «сладкой точки».</Text>
        <Text>Отметить «sweet spot» для микротулз и «зона гибрида».</Text>
        <Text><Todo>Нарисовать простой line chart</Todo></Text>
        <Notes>
          <p><b>(≈20 секунд)</b></p>
          <p>Визуализация главной идеи.</p>
          <ul>
            <li>Для маленьких утилит и скриптов есть "сладкая точка" (sweet spot), где чистый вайбкодинг максимально эффективен и приносит удовольствие.</li>
            <li>С ростом проекта эффективность этого подхода падает, а фрустрация растёт.</li>
            <li>Дальше начинается "зона гибридных методов", где нужно подключать планирование, тесты и контроль.</li>
          </ul>
          <p><b>Переход:</b> Итак, давайте подведём итоги.</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Когда благо, когда блажь</Heading>
        <div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1.25rem'}}>
          <Box>
            <Heading fontSize="h4">Благо</Heading>
            <UnorderedList>
              <ListItem>Маленькие приватные тулзы</ListItem>
              <ListItem>Быстрые эксперименты</ListItem>
              <ListItem>Тестовые стенды</ListItem>
              <ListItem>Навигация по коду</ListItem>
            </UnorderedList>
          </Box>
          <Box>
            <Heading fontSize="h4">Блажь</Heading>
            <UnorderedList>
              <ListItem>Публичные сервисы без ревью</ListItem>
              <ListItem>Погони за «идеальным стеком»</ListItem>
              <ListItem>Игнор тестов/политик</ListItem>
              <ListItem>Слепое доверие агенту</ListItem>
            </UnorderedList>
          </Box>
        </div>
        <Notes>
          <ul>
            <li><b>Благо</b> — это наш второй кейс (Webhook Explorer) и другие примеры утилит. Это инструменты с низкими рисками и высокой отдачей.</li>
            <li><b>Блажь</b> — это история с попытками довести до идеала антиспам-бота. Это погоня за перфекционизмом там, где он не нужен, и слепое доверие технологии.</li>
          </ul>
          <p><b>Главное — понимать рамки применения.</b></p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Итоговый чек-лист</Heading>
        <UnorderedList>
          <ListItem>План ≤7 шагов + критерии.</ListItem>
          <ListItem>Малые итерации; после каждой — тест/снапшот.</ListItem>
          <ListItem>Таймбоксы и стоп-критерии.</ListItem>
          <ListItem>Мини-полиси безопасности.</ListItem>
          <ListItem>Матрица выбора инструмента.</ListItem>
          <ListItem>Пост-мортем и правила команды.</ListItem>
        </UnorderedList>
        <Text>Финальный тезис — «Вайбкодинг — благо в рамках».</Text>
        <Notes>
          <p>Этот слайд — для того, чтобы сфотографировать и унести с собой.</p>
          <p>Если убрать магию и добавить дисциплину, вайбкодинг становится мощнейшим инструментом в арсенале инженера.</p>
          <p>Финальный тезис: <b>Вайбкодинг — это благо, но только в правильно очерченных инженерных рамках.</b></p>
          <p>Спасибо!</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Q&amp;A</Heading>
        <Text>Спасибо!</Text>
        <Notes>
          <p><b>Заготовленные ответы:</b></p>
          <ul>
            <li><b>Про безопасность:</b> "Главный принцип — сужение поверхности атаки. Для внутренних утилит риски минимальны, для публичных — обязателен ревью и гигиена, как на слайде X".</li>
            <li><b>Про выбор инструмента:</b> "Начинаю с простого чата. Если вижу, что он не справляется (битые патчи, много файлов) — перехожу к агенту или гибридному методу. Матрица на слайде Y — хороший ориентир".</li>
            <li><b>Про языки:</b> "Лучше всего модели знают Python, поэтому для быстрых утилит это мой выбор по умолчанию. С TypeScript тоже хорошо. С другими языками — зависит от модели, но обычно сложнее".</li>
          </ul>
          <p><b>Заметка себе:</b> Не забыть, что я использую Gemini 1.5 Pro для задач с большим контекстом. Говорить об этом одинаково, чтобы не путать аудиторию.</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Бэкап: доп. сниппеты</Heading>
        <Text><Todo>Добавить сниппеты кода из кейсов</Todo></Text>
        <Notes>
          <p>Этот и следующие слайды — запасные, на случай вопросов из зала.</p>
          <p>Здесь можно показать куски кода из антиспам-бота или Webhook Explorer, если попросят.</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Бэкап: таблица языков</Heading>
        <Table>
          <TableHeader>
            <TableRow>
              <TableCell>Язык</TableCell>
              <TableCell>Эффективность</TableCell>
              <TableCell>Комментарии</TableCell>
            </TableRow>
          </TableHeader>
          <TableBody>
            <TableRow>
              <TableCell>Python</TableCell>
              <TableCell>Высокая</TableCell>
              <TableCell>Лучший для утилит</TableCell>
            </TableRow>
            <TableRow>
              <TableCell>TypeScript</TableCell>
              <TableCell>Средняя</TableCell>
              <TableCell>Хорош для веб</TableCell>
            </TableRow>
            <TableRow>
              <TableCell>Kotlin</TableCell>
              <TableCell>Низкая</TableCell>
              <TableCell>Сложнее генерить</TableCell>
            </TableRow>
          </TableBody>
        </Table>
        <Notes>
          <p>Для Q&A: если спросят про сравнение языков подробнее.</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Бэкап: чек-лист «починить агента»</Heading>
        <UnorderedList>
          <ListItem>/compact диалог</ListItem>
          <ListItem>Перезапуск</ListItem>
          <ListItem>Один шаг за раз</ListItem>
          <ListItem>Summary прогресса</ListItem>
          <ListItem>Проверить директорию</ListItem>
        </UnorderedList>
        <Notes>
          <p>Для Q&A: если спросят про конкретные приемы работы с агентами, когда они "тупят".</p>
        </Notes>
      </Slide>

      <Slide>
        <Heading fontSize="h3">Бэкап: полезные ссылки</Heading>
        <UnorderedList>
          <ListItem>Aider</ListItem>
          <ListItem>Cursor</ListItem>
          <ListItem>Copilot</ListItem>
          <ListItem>Shotgun Code</ListItem>
          <ListItem>Files-to-prompt</ListItem>
        </UnorderedList>
        <Notes>
          <p>Для Q&A: если попросят список инструментов, которые упоминались.</p>
        </Notes>
      </Slide>
    </Deck>
  );
}
