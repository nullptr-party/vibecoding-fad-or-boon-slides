// src/slides/Deck.tsx
import React from "react";
import {
  Box,
  CodePane,
  Deck,
  Heading,
  ListItem,
  Notes,
  Quote,
  Slide,
  Table,
  TableBody,
  TableCell,
  TableHeader,
  TableRow,
  Text,
  UnorderedList,
} from "spectacle";

// Tiny helpers
const Todo = ({children}: { children: React.ReactNode }) => (
  <span style={{
    padding: '.35rem .5rem',
    border: '2px dashed currentColor',
    borderRadius: '.5rem',
    fontSize: '.9rem',
    display: 'inline-block',
  }}>
    [TODO] {children}
  </span>
);

export default function DeckApp() {
  return (
    <Deck template={() => null}>
      {/* S1 — Титул */}
      <Slide>
        <Heading fontSize="h2">Вайбкодинг — блажь или благо?</Heading>
        <Text>От эйфории к зрелости: как превратить магию в инженерный процесс</Text>
        <Quote style={{opacity: .7, fontSize: '1.5rem'}}>
          Презентация тоже навайбкожена на bun + TS + Spectacle
        </Quote>
        <Notes>Лёгкий тон, без мата на слайде. В речи можно «лайт». Тон лёгкий; без мата на слайдах. Тезис: «магия →
          инженерный процесс». Скажи, что сам делал это на вайбе. Всем привет, меня зовут Илья. Я работаю developer
          productivity инженером, а также релиз-инженером, а также много кем еще, мастером на все руки в компании
          inDrive. В зоне моей ответственности находится наш релизный pipeline и все, что с ним связано. На сегодняшнем
          докладе я бы хотел рассказать вам о том, как вообще я пришел в вайбкодинг, что это такое, зачем это нужно. И
          почему вам, возможно, тоже стоит посмотреть в эту сторону и подумать, какая же это офигенная штука.</Notes>
      </Slide>

      {/* S2 — Хук и цифры */}
      <Slide>
        <Heading fontSize="h3">Хук</Heading>
        <Text>«За год мой антиспам-бот забанил ≈9 000 спамеров с 5–6 ложными банами — и это всё равно не магия»</Text>
        <Text><Todo>проверить цифры по логам</Todo> · <Todo>мини-график «баны по дням»</Todo></Text>
        <Notes>10–12 секунд, чтобы зацепить и перейти к теме ответственности. Ответственность {'>'} вау-эффект. Цифры
          проверить; график показать бегло. Переход: «что такое вайбкодинг?». За год забанено 9000 спамеров. Там чуть ли
          не по 30 в день банится сегодня. Ну, когда-то больше, когда-то меньше. Не суть. И success rate, точнее,
          процент ошибок достаточно низкий. Из этих 9000 человек где-то 5 или 6 были забанены случайно. Ну как, потому
          что нейронка решила, что они спамеры, хотя на самом деле они таковыми не являются. Что я считаю достаточно
          неплохим результатом.</Notes>
      </Slide>

      {/* S3 — План доклада */}
      <Slide>
        <Heading fontSize="h3">План</Heading>
        <UnorderedList>
          <ListItem>Что такое вайбкодинг и где его границы</ListItem>
          <ListItem>Кейс 1: антиспам-бот — «с вау до зрелости»</ListItem>
          <ListItem>Кейс 2: Webhook Explorer + snapshot-тесты — «приложения по запросу»</ListItem>
          <ListItem>Ловушки и гигиена (перфекционизм, sunk cost, безопасность)</ListItem>
          <ListItem><b>Инструменты под задачи</b>: лестница от чата к агентам + матрица выбора</ListItem>
          <ListItem>Гибридный метод: План → Агент → Тесты</ListItem>
          <ListItem>Итоги: когда это благо, когда блажь</ListItem>
        </UnorderedList>
        <Notes>Покажи, что будет раздел про инструменты. Обещай блок про инструменты. 2 кейса → ловушки → практики.
          Цель: «рамки, где вайб — благо». Мой путь с вайб-кодингом начался достаточно давно. Он начался еще в 2024 году
          в марте. Что я тогда вайб-кодил? а точнее, что я тогда использовал для работы с кодом, так или иначе? В те
          далекие незапамятные времена я использовал всем нам сегодня известный Claude 3.5, а точнее он тогда был не
          3.5, я уже не помню, когда я фиксил очень заколебавший меня баг в компиляторе Kotlin. Был у меня такой доклад.
          Рекомендую посмотреть на YouTube, ссылочка будет, хотел сказать, в описании. Ссылочка будет на YouTube. Ой,
          на... этом самом, на слайде.</Notes>
      </Slide>

      {/* S4 — История термина */}
      <Slide>
        <Heading fontSize="h3">История термина «вайбкодинг»</Heading>
        <Text>Термин популяризован Андреем Карпаты (ex-OpenAI) в ноябре 2024 в твитте.</Text>
        <Text><Todo>вынести 1 строку-цитату и дату появления термина</Todo></Text>
        <Notes>Если читать твит, в котором появился этот термин, а появился этот термин где-то в ноябре двадцать
          четвёртого года, то Андрей Карпатый, это бывший разработчик из OpenAI, обрисовал это так: это ситуация, в
          которой ты используешь какого-то кодинг-агента, пишешь ему, что ты хочешь, получаешь какой-то результат, не
          вникая в то, что он там написал, и корректируешь, опять же, каким-то человеческим языком, какими-то обычными
          простыми смыслами, типа «подвинь кнопочку», «сделай так-то», опять же, не вникая, в что там в итоге
          сгенерировалось. Таким образом ты типа программируешь. На вайбе. Скажем так. Многие действительно делают
          именно так. Мне этот подход не очень нравится. Дальше в докладе я наверное расскажу почему. Пока что так.
          Хлебные крошки оставляю.</Notes>
      </Slide>

      {/* S5 — Что такое «вайбкодинг» */}
      <Slide>
        <Heading fontSize="h3">Что такое «вайбкодинг»</Heading>
        <UnorderedList>
          <ListItem>Программируешь намерениями/правками «на человеческом», не вникая глубоко в сгенерированный
            код.</ListItem>
          <ListItem>Идея популяризована в сообществе в конце 2024.</ListItem>
        </UnorderedList>
        <Notes>Дать простое определение. Коротко плюсы/минусы. Пообещать: дальше — «как держать контроль». Пообещай
          вернуться к «как держать контроль». Можно рассказать про первый опыт: первый настоящий опыт вайбкодинга у меня
          случился чуть позже. Он случился в октябре 2024 года, почти год назад.</Notes>
      </Slide>

      {/* S6 — Плюсы вайбкодинга */}
      <Slide>
        <Heading fontSize="h3">Плюсы вайбкодинга</Heading>
        <UnorderedList>
          <ListItem>Скорость разработки</ListItem>
          <ListItem>Низкий порог входа</ListItem>
          <ListItem>«Дешёвые» одноразовые утилиты</ListItem>
          <ListItem>Приложения по запросу</ListItem>
        </UnorderedList>
        <Notes>Подчеркнуть скорость и простоту. Все вокруг говорят о том, что мы уже в эре приложений по запросу, и
          кажется, как минимум для разработчиков это точно так, потому что у нас уже есть навыки для того, чтобы
          отдебажить приложение, привести его в тот вид, который мы хотим. Мы ближе к коду, нам проще. Вайбкодинг
          позволяет писать какие-то штуки вообще без серьезного вникания в доменную область.</Notes>
      </Slide>

      {/* S7 — Минусы вайбкодинга */}
      <Slide>
        <Heading fontSize="h3">Минусы вайбкодинга</Heading>
        <UnorderedList>
          <ListItem>Контроль качества</ListItem>
          <ListItem>Безопасность</ListItem>
          <ListItem>Масштабирование</ListItem>
          <ListItem>Иллюзия контроля</ListItem>
        </UnorderedList>
        <Notes>Обсудить риски. На самом деле там огромное количество подводных камней, про которые я конечно же вам
          сейчас расскажу. Что работает не всегда, работает не всегда так, как ты хочешь, и не всегда быстрее через
          нейронку, чем ручками. Но очень легко попасть в такой цикл, когда ты пытаешься заставить нейронку добить, и не
          получается, а ты снова пытаешься, и прошло уже два часа, и уже проще было руками написать. Но нет, ты
          пытаешься добить нейронкой, чтобы все было нормально. В общем, надо уметь себя останавливать.</Notes>
      </Slide>

      {/* S8 — Кейс 1: контекст */}
      <Slide>
        <Heading fontSize="h3">Кейс 1: контекст</Heading>
        <UnorderedList>
          <ListItem><b>Задача:</b> антиспам в нескольких TG-группах (≈1–4k участников).</ListItem>
          <ListItem><b>Идея:</b> каждое сообщение новичка → LLM-классификация → бан/пропуск.</ListItem>
          <ListItem><b>MVP:</b> на вайбе за ~1–2 часа.</ListItem>
        </UnorderedList>
        <Notes>Подчеркнуть простоту MVP. LLM как классификатор на входе. Минимум кода → быстрая польза. Подчеркни
          простоту MVP. Самый первый мой опыт вайп кодинга произошел... вайп кодинга в том смысле, что я что-то на вайп
          кодил, и у меня случился вау-эффект, после которого я понял, что это действительно может быть полезным
          инструментом, а не какой-то игрушкой. У меня было несколько групп, в которых я либо администрировал, либо, ну,
          типа, это была либо моя группа, либо я в ней был администратором в Телеграме. Там достаточно часто заскакивали
          спам-боты, которые достаточно меня заколебали. Я долгое время их вручную банил, и мне это очень сильно
          надоело. У меня появилась идея, почему бы не сгенерить Телеграм-бота, который будет каждое сообщение юзера,
          нового вошедшего в чат, отправлять в нейронку и просить классифицировать, спам это или не спам. Ну, как бы,
          классно, так и сделаем. В общем, первая версия бота, которая не сильно претерпела изменений за последний год и
          до сих пор работает примерно так же, как и в октябре, была написана за час. Где-то за час. За это время, в
          принципе, я считаю, что это достаточно внушительные результаты. Она администрирует, назовем это так,
          занимается антиспамом в четырех достаточно крупных группах от 1000 до 4000 человек. И успешно справляется со
          своей работой.</Notes>
      </Slide>

      {/* S9 — Кейс 1: результаты */}
      <Slide>
        <Heading fontSize="h3">Кейс 1: результаты</Heading>
        <UnorderedList>
          <ListItem>≈9 000 банов/год; 5–6 ложных — низкий FP.</ListItem>
          <ListItem>Работает без активной поддержки; редкие правки.</ListItem>
        </UnorderedList>
        <Text><Todo>Мини-график/скрин обзора метрик</Todo></Text>
        <Notes>30–40 секунд, не увязнуть в деталях. Цифры — коротко, без деталей. Стабильность/низкая поддержка.
          Переход: «где подвёл чистый вайб». И сейчас я вам рассказал прекрасную линию повествования, которую вы
          увидите, если зайдете в технический твиттер и будете листать его каждый день. Там постоянно появляются чуваки,
          которые такие: «ребята, я заменил на нейронки всю нашу команду разработки и теперь у меня продукт, который
          вышел день назад, зарабатывает 1 миллион баксов в год. Ребята, все, вайбкодинг наше все, разработчики не
          нужны».</Notes>
      </Slide>

      {/* S10 — Кейс 1: где подвёл «чистый вайб» */}
      <Slide>
        <Heading fontSize="h3">Где подвёл «чистый вайб»</Heading>
        <UnorderedList>
          <ListItem><b>Перфекционизм:</b> хотел идеальный login UI и «Python-first» → TS → Rust → Kotlin → обратно
            Python.</ListItem>
          <ListItem><b>Sunk cost:</b> «ещё одна итерация в агенте» — часы ушли, пользы мало.</ListItem>
          <ListItem><b>Не читаю код:</b> риск уязвимостей в публичном сервисе.</ListItem>
          <ListItem><b>Инструментальная ловушка:</b> «делаю только агентом» → тупики на интеграции.</ListItem>
        </UnorderedList>
        <Notes>Честно, с самоиронией. Самоирония про переписывания. Сформулировать анти-паттерн. Мост к «как правильно».
          Взять пример с ботом. Все охеренно, он работает, все классно, но на самом деле та версия, которую я написал,
          была действительно написана за два часа, но потом я потратил несколько дней в попытках дописать её таким
          образом, чтобы типа в моей голове, как вот она выглядела красиво, чтобы вот ровно так она и работала. Там была
          куча борьбы с Питоном. Я его переписывал с Python на TypeScript, я его переписывал с TypeScript на Rust, с
          Rust я его переписывал на Kotlin, потом обратно переписывал его на Python. В процессе каждый раз наталкиваясь
          на большие проблемы, головную боль. И все это произошло исключительно потому, что в процессе я решил, что я
          буду вайпкодером в самом трушном смысле. Я не буду никакой код писать руками, я буду только командовать
          агентом. Со всей ответственностью могу заявить сегодня, что это путь в никуда. Это путь в никуда, если вы
          хотите сделать рабочий продукт, а не состряпанное на коленке решение, которое тем не менее решает задачу. То
          есть если вам достаточно того результата, который вы можете на вайпкодить, и вы не хотите добавлять каких-то
          удобств, не хотите добавлять какую-то архитектуру, еще что-то, то вайпкодинг — ваше все. В противном случае, к
          сожалению, придется переходить к каким-то более комплексным подходам в AI-assisted разработке, назовем ее так.
          В принципе, это достаточно устоявшийся сегодня термин. Эпопея с ботом не завершилась после того, как я
          прострадал и в итоге залил в продакшн самую первую версию, которая работала, хоть и худо-бедно, потому что за
          последний год я пытался его переписывать 4 или 5 раз, потому что в моей голове этот бот выглядел как, блин,
          готовый продукт. Собственно, спустя 3 месяца после того, как он у меня заработал, вышел всеми любимый, всем
          известный LOLZ Anti-Spam бот, который захватил весь телеграм, по крайней мере, русскоязычный, снгшный. Во
          многих чатах используется этот бот, и у него, в принципе, под капотом ровно такая же история, работает, как и
          у меня. Он сканирует сообщение с помощью нейронок на предмет спама. Все. Только судя по всему, ребята кодили
          его еще и сами руками, потому что на вайб-коде такой достаточно большой функционал, ну, в моей голове не
          представляется возможным, если только не подходить к этому с каким-то более инженерным подходом, назовем
          так.</Notes>
      </Slide>

      {/* S11 — Кейс 1: перфекционизм в деталях */}
      <Slide>
        <Heading fontSize="h3">Кейс 1: перфекционизм в деталях</Heading>
        <UnorderedList>
          <ListItem>Хотел веб-логин UI на Python-first фреймворках</ListItem>
          <ListItem>Переписывал языки из-за идеальной картины</ListItem>
          <ListItem>В итоге: простая сессия без UI</ListItem>
        </UnorderedList>
        <Notes>Обсудить, почему перфекционизм + вайб = ад. Вот этот антиспам-бот как работает? Он подключается как
          обычный пользователь в Телеграме. Так называемый юзер-бот. То есть не боты телеграммные, а юзер-бот. Он как бы
          симулирует пользователя. Он подключается как обычный юзер в Телеграме и ведет себя как бот. Проблема
          следующая. Чтобы подключиться как обычный юзер в Телеграме, нужно пройти аутентификацию. То есть если у тебя
          есть бот обычный, то у тебя просто строчка, которую ты подставляешь, и эта строчка — типа вот это ключ к API,
          и все работает. В случае с юзером так не получится. Тебе нужно ввести номер телефона, по которому бот должен
          подключиться к Телеграму, получить SMS-ку или QR-код отсканировать, или еще что-то, чтобы бот залогинился и
          получил сессию, куда-то её положил и продолжил после этого работать нормально. И все классно работало локально
          до момента, пока я не попытался, собственно, это в продакшн задеплоить к себе на сервер. Что надо было сделать
          изначально? Надо было просто взять, залогиниться локально, скопировать сессию, файлик, типа, на сервер и все.
          И все было бы хорошо. Но я же ебучий перфекционист. Я так не могу. Поэтому я начал пытаться заставить нейронку
          сделать так, чтобы у меня в боте еще был веб-сервер, который выдает мне страничку для логина. Куда я могу
          зайти, ввести номер телефона, отсканировать QR-код или ввести код, нажать кнопочку «Login», и он бы там все
          сохранил, и все было бы охеренно. Вот что я хотел. Причем я это хотел так, чтобы у меня использовалось минимум
          сторонних технологий. В идеале я хотел, если на Питоне, то использовать фреймворки, которые позволяют типа
          «Python First». То есть там есть набор фреймворков, которые позволяют тебе на Питоне описать интерфейс, еще
          что-то, а под капотом оно вот это какой-то фарш провернет, у тебя получится HTML, CSS, JS, API какое-то, чтобы
          с сервером вот это вот все дерьмо общалось. Понятно, да? То есть я хотел, чтобы все было на Питоне, и я думал,
          что это классно сработает для агента в том числе, потому что если все будет на Питоне, то все будет работать,
          все будет гораздо проще редактировать, когда у тебя нету целой кучи разрозненных файлов. То есть я не хочу вот
          для такой простой задачи отдельно какой-то API делать, отдельно какой-то API-клиент на клиенте, отдельно на
          JavaScript там что-то писать. Очень неприятно, мне не нравится. Мой перфекционизм как бы негодует по таким
          штукам. Поэтому я хотел, чтобы все работало вот так, типа «Python first» или «TypeScript first». Собственно,
          когда на Питоне не получилось сделать все это там за какое-то удобоваримое время, я такой: «бля, это дерьмо,
          Питон ваш, пойду напишу на TypeScript бота». Говорю: «перепиши мне бота на TypeScript и сделай задачу с
          логином только на TypeScript, чтобы всё было». И там тоже ничего не заработало. Я пытался, чтобы заставить
          именно агента это сгенерить, не ручками, не хотел ручками. Нихуя не получилось. Я такой: «ладно, на Расте
          попробую». Тоже ничего не получилось. Ну и в итоге я просто откатился обратно и сделал ровно то, что нужно
          было сделать изначально. Я просто подсунул файлик, и все заработало. У меня нету красивой логин-формы, но как
          бы, ну и ладно. Мне ни разу за год не пришлось перелогиниться. Потраченные усилия — это следствие моего
          перфекционизма. То есть большое количество людей просто забило бы хуй, задеплоило, и все было бы работало.
          Собственно, я в итоге так же и сделал. Я забил хуй, задеплоил, и все работает. Но типа, это буквально вот эта
          вот вайб-кодинг дыра. Типа перфекционизм плюс вайб-кодинг — это вообще путь в никуда, по-моему, потому что
          очень часто это приводит к какому-то аду.</Notes>
      </Slide>

      {/* S12 — Кейс 1: sunk cost в деталях */}
      <Slide>
        <Heading fontSize="h3">Кейс 1: sunk cost в деталях</Heading>
        <UnorderedList>
          <ListItem>Пытался развить в продукт (подписки, группы)</ListItem>
          <ListItem>Переписывал 4-5 раз за год</ListItem>
          <ListItem>В итоге: MVP работает, развитие отложено</ListItem>
        </UnorderedList>
        <Notes>Обсудить ошибку невозвратных затрат. Я еще говорил про то, что я в течение года пытался переписывать
          бота. Я пытался уже делать типа крутого бота. То есть чтобы можно было в него там, не знаю, ты зашла в
          Telegram, у меня есть группа, ты зашла, типа: «бот, добавься в эту группу, типа, смотри на нее». Там
          какой-нибудь лимит по количеству сообщений, а если там больше сообщений, чем нужно, то ты там платишь денежку
          небольшую мне, допустим, чтобы оплачивать запросы в нейронку. Ну, то есть уже какой-то продукт развить хотел.
          Соответственно, там я уже подходы другие использовал. Я уже, типа, генерил в Gemini какие-то планы для
          разработки, чтобы потом агент по этим планам для разработки разработал, собственно, новую версию бота на
          другом языке, на TypeScript, я думаю. И там тоже все плюс-минус начинало куда-то идти, но, так как только
          проект разрастался, появлялись вот эти проблемы, что агент перестает понимать проект целиком и начинает терять
          контекст и начинает писать херню по сути. Особенно это усугублялось тем, что я не хотел ручками ничего
          проверять, я хотел, чтобы у меня были автоматизированные тесты, которые сами все проверяют. Автоматизированные
          тесты — это значит, что у тебя есть проект на там 3000 строк, а чтобы покрыть его тестами, тебе нужно еще
          15000 строк тестов. И эти 15000 строк тестов просто как бы приводят к тому, что у тебя перестает опять влезать
          в контекст проект, и агент начинает умирать. В общем, и в итоге я так и не переписал бота, потому что я не
          хочу его руками писать, а типа суперкрупный проект написать именно чистым вайб-кодингом достаточно
          сложно.</Notes>
      </Slide>

      {/* S13 — Кейс 1: гигиена */}
      <Slide>
        <Heading fontSize="h3">Кейс 1: как правильно (гигиена)</Heading>
        <UnorderedList>
          <ListItem>Команды только от супер-админа/вайтлист ролей.</ListItem>
          <ListItem>Логин один раз локально → перенос сессии на сервер (без «красивого» UI).</ListItem>
          <ListItem>Логи и простые алерты (всплеск банов/ошибок).</ListItem>
        </UnorderedList>
        <Text style={{fontSize: '.9rem'}}><b>Стоп-критерии:</b> 2 фейла подряд → смена инструмента/урезать фичу;
          если <code>T_LLM &gt; T_manual</code> дважды — стоп.</Text>
        <Text style={{fontSize: '.9rem'}}><b>Итог:</b> «вайб» — для MVP; дальше — рамки и контроль.</Text>
        <Notes>Подчёркни «узкую поверхность атаки». Сузить поверхность атаки. Стоп-критерии проговорить. Акцент: «вайб»
          ≠ «без контроля».</Notes>
      </Slide>

      {/* S14 — Кейс 2: боль и цель */}
      <Slide>
        <Heading fontSize="h3">Кейс 2: боль и цель</Heading>
        <UnorderedList>
          <ListItem><b>Сервис:</b> сбор метрик CI/CD, тонна GitHub webhooks.</ListItem>
          <ListItem><b>Цель:</b> менять логику, не ломая старое; быстро собирать тестовые наборы из реальных
            событий.</ListItem>
        </UnorderedList>
        <Notes>Подвести к «чёрному ящику». Проблема: много событий/форматов. Цель: регресс не сломать. Подвести к
          «чёрному ящику». Следующий проект, с которым также случился еще больше вау-эффект, то есть это в моей голове
          был прям immediate success. То есть я просто прям за пять минут на вайп кодил ровно то, что нужно, она
          заработала ровно так, как нужно, и решила ровно вот эту конкретную проблему, которую мне нужно было решить вот
          в этот данный момент. И если бы я не на вайп кодил это решение, то решение этой проблемы заняло бы у меня
          кратно больше времени. То есть не 5 минут, не 10 минут, а там три часа. Неприятненько было бы. Это,
          собственно, еще один достаточно интересный трек вайп кодинга. То есть интересный способ использовать
          AI-assisted разработку, просить агентов или нейронки сгенерить вам какой-то код для решения каких-то
          конкретных задач в вашей работе. Приведу пример, вот этот самый, о котором я начал говорить. У нас на работе
          есть сервис, который занимается сбором метрик. У нас есть CI/CD pipeline. Он там, в нем целая куча задач,
          которые как-то там крутятся-вертятся, хуй вертятся, и эти задачи занимают какое-то время. И мне, как инженеру
          релизного пайплайна, CI/CD пайплайна, нужно иметь возможность понимать, вообще в каком он состоянии, есть ли
          там какие-то проблемы, может навесить какие-то алерты, что у нас внезапно там все встало, джобы больше не
          крутятся, или что за последнюю неделю у нас там стало лучше или хуже по времени исполнения билда. Примерно
          понятно, да? Соответственно, для того, чтобы собирать эти метрики, у нас есть специальный сервис. GitHub умеет
          отправлять так называемые вебхуки. Что такое вебхук? Кратенько. Ты можешь поднять какой-то веб-сервер, который
          слушает от GitHub какие-то события. И вебхуки — это по сути GitHub. GitHub можно сказать: «смотри, вот наш
          сервис вот тут. Пожалуйста, отправляй в него события. Такие-то». Собственно, вебхук — это по сути вот какая-то
          точка, в которую GitHub может смотреть и туда управлять события. Понятно примерно? Эти вебхуки, по сути,
          сообщают о том, когда джоба началась, когда джоба закончилась, что в процессе произошло, упала это джоба или
          не упала. То есть там достаточно до хрена всякой разной инфы. И в процессе написания метрик-сервиса, он был
          написан до меня, мне нужно было вносить в него изменения, достаточно крупные. И мне понадобилось, как-то не
          сильно вникая в достаточно сложно устроенный сервис, сделать так, чтобы после моих изменений там ничего не
          сломалось и все работало примерно так же, как и раньше. Ну и, соответственно, мои изменения тоже
          заработали.</Notes>
      </Slide>

      {/* S15 — Кейс 2: черный ящик */}
      <Slide>
        <Heading fontSize="h3">Решение: «чёрный ящик» + снапшоты</Heading>
        <UnorderedList>
          <ListItem>Поднимаем сервис и БД; на вход — реальные вебхуки; на выходе — состояние БД → снапшотим.</ListItem>
          <ListItem>LLM генерит каркас тестового стенда.</ListItem>
          <ListItem>Валидируем: на одинаковом входе всегда одинаковый снимок.</ListItem>
        </UnorderedList>
        <Notes>Визуализируй потоки. Объяснить поток: вход → БД → снапшот. Детерминизм как критерий. Связать с Explorer.
          И ко мне пришла гениальная идея. Я здесь в этой задаче использовал сразу же две вайб-кодинг методики. Первое,
          я решил, что прежде чем что-то делать с этим сервисом, я возьму весь этот сервис целиком, я его положу в
          нейронку, скажу: «нейронка, посмотри на вот этот сервис и напиши мне так называемые снэпшот-тесты».
          Снэпшот-тесты — это такая штука, которая, по сути, ну, по крайней мере, мои тесты вот так вот были устроены. Я
          на самом деле не сильно силен в терминологии, но мои тесты были устроены следующим образом: вот есть сервис,
          мы его считаем черным ящиком. Мы берем, поднимаем этот сервис, подсовываем ему с одной стороны базу данных,
          куда он это все складывает, вот эти все метрики результирующие, а на вход мы ему подсовываем прям типа слепок
          реальных данных. Мы берем вот там до херища вебхуков, взяли, да? Скормили ему на вход. По сути, типа, через
          вот этот черный ящик они прошли, в базу что-то записалось. Я взял, сохранил это состояние базы данных на диск,
          и теперь мои тесты валидируют, что при вот таком входе мы всегда должны получать вот такой выход. И если я в
          сервисе что-то поломал, то фарш не провернется или провернется неправильным образом. Благодаря этим тестам я
          смогу убедиться, что старая функциональность работает так, как ожидалось. Примерно понятно? Соответственно,
          для чего я использовал нейронки? Во-первых, я использовал нейронки для генерации тестового фреймворка для вот
          этого всего дерьма. То есть сверху сервиса она вернула много кода, который я особо сам не вникал, убедился,
          что он работает просто, который, собственно, и разворачивает вот это тестовое окружение, где у нас сервис как
          черный ящик, на вход подаются какие-то данные, на выходе они кладутся в базу, и в базу мы снэпшотим.</Notes>
      </Slide>

      {/* S16 — Кейс 2: Webhook Explorer */}
      <Slide>
        <Heading fontSize="h3">Webhook Explorer (утилита «по запросу»)</Heading>
        <UnorderedList>
          <ListItem>За 5–20 минут LLM сгенерила GUI на Python: фильтр по PR/статусу/времени, сбор групп событий, экспорт
            кейсов.</ListItem>
          <ListItem>«Руками» заняло бы ≈3 часа.</ListItem>
        </UnorderedList>
        <Text><Todo>Скриншот GUI; пояснить поля фильтров</Todo></Text>
        <Notes>Подчеркни: «раньше я бы даже не писал такую утилиту». Подчеркнуть «раньше бы не писал». Фильтры: PR,
          статус, время. Экспорт наборов → тесты. Но в этой задаче есть большая проблема. Мне нужно было сделать
          снэпшот-тесты на конкретные слепки вот функциональности сервиса. То есть что он правильно выдает информацию по
          пул-реквесту, у которого job зафейлилась, или у которого job прошла нормально. То есть мне нужно было входные
          данные как-то рассортировать по каким-то вот типа «вот эта пачка вебхуков», то есть «вот эта пачка событий»
          отвечает, типа, должна выдавать такой результат. «Вот эта пачка событий» должна отдавать другой результат. На
          разные входы должен получаться разный выход. И мне нужно вот это все было как-то закрепить. И, ну, это
          достаточно геморная задача, как ты можешь понять. Типа ручками это все делать достаточно больно. Там типа на
          одну джобу у нас может прилететь 40 событий. А джоб этих там 25, а пул-реквестов там сотни. То есть это просто
          невероятно сложно все это ручками все это перелопатить. А раньше я бы, наверное, попросил нейронку:
          «сгенерируй мне, пожалуйста, скрипт, который позволит мне экспортировать такие данные, или еще вот такие
          данные, или еще что-то». Но здесь я применил вайбкодинг методику, просто как ниндзя. Я взял, скачал все
          веб-хуки за последние три дня, а потом скормил нейронке чуть-чуть вебхуков, показал, как они выглядят, и
          сказал: «напиши мне прям типа графическую программу на Питоне, которая читает папочку с веб-хуками и дает мне
          возможность накликать всякие фильтры и сгруппировать их по разным признакам. По номеру pull request, потому
          завершились они успешно или не успешно, когда они произошли, ну всякое такое. А потом поставить галочками,
          которые мне нужны, типа группы, и экспортировать их». И по сути, у меня за 5 минут мне нейронка сгенерировала
          готовую программу на Питоне на 800 строк, которую я бы руками заебался писать, если честно. В которой я могу
          просто скормить все эти скачанные вебхуки, натыкать, что мне надо для конкретных тест-кейсов, экспортнуть, и
          типа все. Вот у меня есть папочка с событиями. Я провернул фарш, сохранил результат. Еще папочка с событиями,
          также провернул результат, сохранил фарш. В итоге у меня есть типа input и output, и все работает. Зачем я это
          все рассказывал? Я это все рассказывал, потому что вайбкодинг открывает для нас, AI-assisted разработка
          открывает для нас невиданную доселе возможность писать приложения или инструменты по запросу, под задачу. То
          есть до появления нейросетей писать программу ради того, чтобы решить вот подобную задачу, мне бы даже в
          голову не пришло. Я бы не тратил свое собственное время на то, чтобы этим заниматься. Это просто бессмысленно.
          Но с появлением нейросетей оказалось, что, ну, если я это сам не пишу, это можно сгенерировать за 5 минут, это
          охеренно. Типа, конечный результат этой программы, доработанный, все время, которое было потрачено на
          первоначальную генерацию и на доработки, и фиксы багов в диалоге с нейронкой, ну, от силы 20 минут занимает. И
          сейчас это типа достаточно такой мощный инструмент, который позволяет анализировать вебхуки Гитхаба и
          экспортировать там из них какие-то сабсеты, какие-то подмножества этих вебхуков по заданным заранее
          параметрам. И добавлять эти параметры не сильно сложно.</Notes>
      </Slide>

      {/* S17 — Кейс 2: ROI и ловушки */}
      <Slide>
        <Heading fontSize="h3">ROI и ловушки</Heading>
        <UnorderedList>
          <ListItem><b>ROI:</b> 3 часа → ≈20 минут (генерация + фиксы).</ListItem>
          <ListItem><b>Валидация:</b> «сгенерилось» ≠ «надёжно» → минимум снапшотов (happy/fail).</ListItem>
          <ListItem><b>Данные:</b> не утащить секреты/PII в промпты/репо.</ListItem>
          <ListItem><b>Иллюзия контроля:</b> важнее корректно группировать вход/выход, а не «красота GUI».</ListItem>
        </UnorderedList>
        <Notes>Одной цифры ROI достаточно. Секреты/PII — не утаскивать. Приоритет: корректный dataset. Это, как бы, с
          моей точки зрения, достаточно яркий пример.</Notes>
      </Slide>

      {/* S18 — Мини-сниппет снапшота */}
      <Slide>
        <Heading fontSize="h3">Мини-сниппет снапшота</Heading>
        <div style={{fontSize: '.8rem', lineHeight: 1.2}}>
          <CodePane language="diff">
            {`
            - before: metrics.job_duration[pr=123, status=failed] = 00:00:00
            + after:  metrics.job_duration[pr=123, status=failed] = 00:07:42
            `}
          </CodePane>
        </div>
        <Text><Todo>Заменить на реальный короткий diff/фрагмент дампа БД (≤7 строк)</Todo></Text>
        <Notes>Не погружайся глубоко; показать принцип фикса состояний. Показать принцип снапшота. Коротко, без деталей.
          Связать с кейсом 2.</Notes>
      </Slide>

      {/* S19 — Почему «чистый вайб» ломается */}
      <Slide>
        <Heading fontSize="h3">Почему «чистый вайб» ломается</Heading>
        <UnorderedList>
          <ListItem>Контекст и патчи: модели путают номера строк → diff рвётся.</ListItem>
          <ListItem>Агенты: теряют рабочую директорию, пропускают файлы, зацикливаются.</ListItem>
          <ListItem>Языки: Python &gt; TypeScript &gt; … (по опыту 2024–2025).</ListItem>
          <ListItem>Перфекционизм + публичный периметр = рост риска уязвимостей.</ListItem>
          <ListItem>Sunk cost: «уже столько вложили…»</ListItem>
        </UnorderedList>
        <Notes>За 60–90 секунд пройтись по пунктам. Назвать типовые failure modes. Личный опыт по языкам. Мост к
          контрмерам. Там типа, я здесь наверное добавлю красивый график, мне нравится, на котором нарисована размер
          проекта и там кривая: сложность кодовой базы растет, эффективность вайбкодинга падает, удовольствие
          разработчика падает.</Notes>
      </Slide>

      {/* S20 — Ловушка: перфекционизм */}
      <Slide>
        <Heading fontSize="h3">Ловушка: перфекционизм</Heading>
        <UnorderedList>
          <ListItem>Погони за «идеальным стеком»</ListItem>
          <ListItem>Переписывания без пользы</ListItem>
          <ListItem>Сочетание с вайбом — ад</ListItem>
        </UnorderedList>
        <Notes>Примеры из кейса 1. Перфекционизм плюс вайб-кодинг — это вообще путь в никуда, по-моему, потому что очень
          часто это приводит к какому-то аду.</Notes>
      </Slide>

      {/* S21 — Ловушка: sunk cost */}
      <Slide>
        <Heading fontSize="h3">Ловушка: sunk cost</Heading>
        <UnorderedList>
          <ListItem>Ошибка невозвратных затрат</ListItem>
          <ListItem>Мем про вагонетку: остановить можно сейчас</ListItem>
          <ListItem>2 фейла — смена подхода</ListItem>
        </UnorderedList>
        <Notes>Мем про трамвай и людей. Можно остановить вагонетку в любой момент, но тогда те, кто уже умер, умерли
          зря. Это частный случай ошибки невозвратных затрат. Это когнитивное искажение, которое, собственно,
          описывается тем, что человек не может остановить работу в каком-то ключе, потому что он уже потратил
          достаточно большое количество сил и не может выкинуть их зря, вот эти потраченные усилия. Это правда большая
          проблема, я все еще с ней борюсь. Не знаю, я пока не поборолся. Просто скажу, как есть, что, ну,
          бывает.</Notes>
      </Slide>

      {/* S22 — Ловушка: безопасность */}
      <Slide>
        <Heading fontSize="h3">Ловушка: безопасность</Heading>
        <UnorderedList>
          <ListItem>Не вникая — риски уязвимостей</ListItem>
          <ListItem>Для публичных сервисов — ревью обязательно</ListItem>
          <ListItem>Сужение поверхности атаки</ListItem>
        </UnorderedList>
        <Notes>Самая большая проблема чуваков, которые не вникают, в том, что если ты пишешь какой-то публичный сервис,
          то, к сожалению, мы живем в таком мире, что на первое место по проблематичности вайп-кодинга выходит
          безопасность. Безопасность того кода, который твой агент сгенерит. С большой долей вероятности у тебя будут
          какие-то объективные, очевидные security-ишью, которые, если ты не будешь смотреть в код, ты пропустишь. Даже
          если ты будешь смотреть в код, ты их тоже пропустишь, потому что нужна экспертиза для того, чтобы понимать,
          что у тебя вообще есть какие-то уязвимости. Что они вообще существуют. Есть классы задач, в которых это
          нормально. Я же там дальше раскрывал, что есть достаточно большой класс задач, в которых... Ну, как бы, вот та
          штука, которую ты навайб-кодил... Ну, вот представим шарик... О, представим клетку. О, кайф. Штука, которую ты
          навайб-кодил, — это клетка. У этой клетки есть какой-то типа навайб-коденный набор рецепторов. Типа, как с ней
          можно провзаимодействовать снаружи. И в зависимости от типа скоупа вот этих рецепторов, типа скоупа опишек,
          которыми может потрогать кто-то внешний, ну, может быть такое, что вот эти вот опишки, они типа криво написаны
          и уязвимы. Но, допустим, в моей задаче у меня очень небольшой набор мест, где можно потрогать моего бота. То
          есть там нету security-уязвимостей в классическом плане, потому что кроме, типа, там есть одно единственное…
          ладно, окей, я туда смотрел, чтобы это было. Там есть типа проверка, что вот супер-админ написал сообщение,
          значит, можно команду от него выполнять. Все. Больше ничего нельзя делать никому. То есть у меня там есть
          вообще супертопорный механизм обрубания любых security issues. Если это написал не я, то вы идете нахуй.
          Точнее, там уже все развилось чуть-чуть больше, там теперь админы группы вроде как могут. Ну не суть. Ну да, я
          смотрю на security issues, потому что я начитался огромное количество тредов в твиттере, где чуваки на
          вайп-кодили какую-нибудь херню, а потом у них все сломали. Соответственно, есть скоуп задач, в которых у тебя
          вообще нет взаимодействия внешних людей с твоим продуктом. С большой долей вероятности там не будет security
          проблем, либо они будут не иметь никакого значения, потому что с ними никто не может
          взаимодействовать.</Notes>
      </Slide>

      {/* S23 — Контрмеры к ловушкам */}
      <Slide>
        <Heading fontSize="h3">Контрмеры к ловушкам</Heading>
        <UnorderedList>
          <ListItem>Делить патчи на файлы/малые MR.</ListItem>
          <ListItem>Для агентов: <code>/compact</code>, перезапуск, summary-файл прогресса.</ListItem>
          <ListItem>Выбирать язык, где модель сильнее, для одноразовых тулз.</ListItem>
          <ListItem>Мини-полиси безопасности и фича-флаги «off by default».</ListItem>
          <ListItem>Таймбоксы: ≤15 минут на микротулзу; 40 минут без прогресса → стоп.</ListItem>
        </UnorderedList>
        <Notes>Связать с кейсами. Схема: дробить → фиксировать прогресс. Язык под задачу. Таймбоксы озвучить.</Notes>
      </Slide>

      {/* S24 — Другие примеры вайба */}
      <Slide>
        <Heading fontSize="h3">Другие примеры вайба</Heading>
        <UnorderedList>
          <ListItem>Bash/YAML конфиги без ручного кода</ListItem>
          <ListItem>CI-проверки/линтеры-эвристики</ListItem>
          <ListItem>Красивые отчёты в PR</ListItem>
          <ListItem>Навигация в legacy-коде</ListItem>
        </UnorderedList>
        <Notes>Вайб-кодинг помогает, по крайней мере в моей работе, достигать результатов в legacy либо в неприятных для
          взаимодействия кодовых базах, назовем это так. Например, большая часть моей работы связана с тем, чтобы писать
          ямлы, заниматься ямл-программированием, а также баш-программированием, потому что я DevOps. Баш — это
          удивительный язык, у которого есть невероятно исключительная, я бы сказал, черта. Причем она замечена многими
          людьми, не только мной. Она заключается в том, что ты никогда не знаешь баш. Если ты, типа, не пишешь баш 24
          на 7, то с большой долей вероятности, каждый раз, когда ты будешь приходить и тебе придется писать
          баш-скрипты, каждый раз тебе придется гуглить, как там писать условия, как там писать циклы, как там писать
          что угодно. Ты никогда не знаешь баш. Это очень мерзкое свойство языка, и поэтому я невероятно не люблю баш.
          Собственно, когда я только пришел на свою текущую позицию, у нас было очень много на баше всего унаследовано.
          У меня есть отвращение к башу. Вот прям отвращение. Я не могу писать баш, меня он бесит. Спасибо нейронкам.
          Мне не пришлось тронуть ни одной строчки кода на баше за последний год с момента моего попадания в inDrive, с
          момента старта моего нового карьерного трека в inDrive, я ни одной строчки на баше не написал. Все строчки на
          баше за меня писала нейронка. Это еще один пример. То же самое и с ямлами. На самом деле, большая часть наших
          ямлов, ну типа конфигурация пайплайнов, написана нейронками. Туда же, наверное, можно засунуть всякие вот
          какие-то простенькие вещи. Типа вот у нас был чувак... у меня есть коллега из команды Mobile Integrity. Это
          команда, которая занимается какими-то платформенными вещами для наших разработчиков. У них там была задача
          сделать какой-то CI/CD пайплайн небольшой, который там какую-то валидацию проводит. И ну все классно, он все
          сделал, но output мне не понравился. Я предложил помощь и буквально за 10 минут с помощью нейронки
          сгенерировал красивый, приятный для чтения отчет. То есть когда на пулл-реквесте у разработчика что-то падает,
          вот конкретно вот эта штука, которую он написал, теперь там есть красивая табличка с понятным описанием, что
          пошло не так, со ссылочками, в общем, просто приятно. И классно, что если бы я писал это руками, то скорее
          всего я бы это не написал, потому что не было бы в лом. А так я смог типа вот так за пару минут взять и
          сгенерировать ровно то, что я хочу, она красиво выглядит, все довольны. Я считаю, офигенно. Еще я, в принципе,
          использовал вайб-кодинг, типа, вайб-кодил какие-то проверки на CI. То есть вот у нас есть какие-то правила, по
          которым код надо писать. И вместо того, чтобы всем ходить и говорить: «Эй, не надо так писать», у нас есть,
          собственно, у нас есть подход, в котором мы пишем автоматизированные проверки, которые посмотрят на исходный
          код, находят там какие-то, ну, типа, какими-то эвристиками находят проблемы, о которых мы договорились, что
          так делать не надо, и уведомляют разработчика о том, что он там что-то допустил какую-то ошибку. И эти
          проверки вообще прекрасно пишутся при помощи нейронок. Я парочку написал буквально там за три-четыре минуты.
          Отлично работают, просто офигительно.</Notes>
      </Slide>

      {/* S25 — Инструменты под задачи: «лестница» */}
      <Slide>
        <Heading fontSize="h3">Инструменты под задачи — «лестница»</Heading>
        <UnorderedList>
          <ListItem><b>Уровень 1 — Чат LLM:</b> ChatGPT/Claude/Gemini/Grok и т.п.</ListItem>
          <ListItem><b>Уровень 1.5 — files-to-prompt/патчи:</b> формируем контекст из папок/файлов.</ListItem>
          <ListItem><b>Уровень 2 — Большой контекст:</b> план/ревью/патчи по всему проекту.</ListItem>
          <ListItem><b>Уровень 3 — Агенты:</b> Aider, Cursor/Kiro, Copilot Chat и т.п.</ListItem>
        </UnorderedList>
        <Notes>Это каркас на 3 следующих слайда. Идея: поднимать уровень по сигналам. Примеры инструментов перечислить.
          Это каркас для следующих 3 слайдов. Теперь поговорим про подходы к вайп кодингу. Потому что их достаточно
          много, инструментов достаточно дохрена, делать можно много чего. Обозреть необозримое, объять необъятное.
          Давайте попробуем что-нибудь объять. Собственно, на сегодняшний день у нас есть, можно небольшую классификацию
          произвести. У нас есть простые интерфейсы для взаимодействия с большими языковыми моделями. Это всем нам
          известный чат GPT, Gemini, Cloud, Grok, DeepSeek, миллионы их. У вас там простой обычный чат-интерфейс, в
          котором вы взаимодействуете с нейронкой. Вы можете взять, скормить ей какую-то информацию и попросить там
          сгенерировать какой-то код, она вам его выдаст. Вы его скопируете себе в IDE, проверите, что не работает,
          скопируете обратно ошибочки и вот в таком цикле попробуете поработать. Это достаточно неплохо работает, и
          когда у тебя не сильно большая кодовая база, благо у современных нейронок почти у всех достаточно большое
          контекстное окно, в которое вылезает, ну, типа, среднего размера проекта. Ладно, не среднего размера, ну,
          типа, там пару-тройку тысяч строк кода туда влезает и достаточно эффективно оно работает. Достаточно неудобная
          история, особенно, когда ты ручками там что-то копируешь, куда-то вставляешь. Следующий уровень, на котором я
          прожил несколько месяцев, наверное, месяцев 5-6 и, в принципе, до сих пор так делаю иногда, это использовать
          какую-то утилитку. Их достаточно дохрена всяких разных. Я использую так называемую files-to-prompt. Утилитка,
          которой можно скормить папочки либо файлики, и она тебе их превратит в понятную, удобную для чтения нейронкой
          такую огромную портянку, которую ты вставляешь в чатик, пишешь, что надо сделать, вставляешь ее в чатик,
          нажимаешь Enter, и нейронка тебе выдает по твоему запросу новую версию твоих файликов или новые файлики, или,
          если у тебя не сильно большая кодовая база, ты можешь попросить эту нейронку выдать тебе патч-файл, который
          можно применить. Патч-файл — это файлики, которые описывают изменения. Типа, вот у тебя есть набор файликов и
          в патче написано: «вот эту строчку удалить, вот эту добавить». И это стандарт, благодаря чему ты можешь вот
          этот файлик скопировать. Допустим, во всех JetBrains IDE есть возможность применить патч из буфера обмена. Ты
          нажимаешь кнопочку, у тебя появляется удобный интерфейс, где написано, что изменено, в каких файлах, и
          кнопочка «применить». Классно, удобно. Это начинает ломаться с какого-то размера контекста, потому что
          нейронки с большим трудом умеют считать. А в патч-файлах, к сожалению, есть номера строк. Это означает, что
          нейронка неизбежно будет ошибаться с номерами строк, а при ошибке с номерами строк ломается весь патч.
          Соответственно, просто какие-то кусочки не будут применены. С какого-то момента это перестает работать, к
          сожалению. Тут мы приходим к гибридному подходу, который я проговорю дальше. А пока что я проговорю про то,
          как можно оптимизировать этот процесс. Собственно, с недавних пор у нас есть от Google нейронка Gemini 1.5
          Pro, которое достаточно неплохо пишет код, при этом у нее есть невъебенных размеров контекстное окно, просто
          пиздец. Типа, в него влезает очень много всего. И где-то 20% этого контекстного окна очень эффективно
          используются нейронкой. То есть она может качественно их воспринимать и качественно выдавать результат. Что
          это означает? Это означает, что большое количество проектов вы можете просто взять, запаковать целиком в этот
          вот суперпромт, запихнуть нейронку, сказать ей, что надо делать и получить прям вот патч, например, который
          будет работать. Даже если патч сломается, то мы переходим к гибридному формату. Можно просить нейронку... А,
          стоп, назад чуть-чуть откатываемся. Например, есть классная тулзовина от Глеба Кудрявцева, называется Shotgun
          Code. Это тулзовина, по сути, типа, ты ее натравливаешь на папочку, отмечаешь галочками, что ты хочешь
          положить, выбираешь там из предопределенных либо пишешь свой промпт, типа: «найди баг», или там «составь план
          разработки», или еще что-нибудь там сделай. В общем, там достаточно много различных вариантов, как можно с
          Gemini работать, благодаря тому, что у нее есть огромный контекст, в который помещается почти весь проект,
          может поместиться весь проект средних размеров. Собственно, благодаря этому у нас есть гибридный формат. Мы
          можем взять, запихать в Gemini вот эту портянку со всем проектом и, например, либо попросить ее выдать
          изменения, не обязательно в виде патча, которые нужно применить для того, чтобы доработать проект. А потом
          взять, скопировать эти изменения и вставить их в кодинг-агента. Тут мы приходим к следующему классу
          инструментов для работы с AI-assisted разработкой. Эти инструменты называются агенты. Они есть в самых разных
          форматах. Они есть в виде плагинов к IDE, это, например, GitHub Copilot. Они есть в виде отдельных IDE,
          точнее, отдельных текстовых редакторов, которые пытаются казаться IDE, например, Cursor или, например,
          какой-нибудь Kiro. Короче, миллион этих различных плагинов. Есть еще достаточно популярный Aider, есть Mentat.
          Это я все запихну на слайд, чтобы все знали, что есть такие инструменты. Но также есть прям автономные
          кодинговые агенты. Например, достаточно популярный, наверное, один из самых популярных и один из первых под
          названием Aider. Это, по сути, командная тулза в командной строке, в которой ты можешь ставить задачи, она в
          автономном режиме что-то делать, а потом возвращаться к тебе с результатами. Ты можешь ей снова ставить задачи
          и так далее, и так далее. По сути, под капотом это просто while true, в котором он идет в нейронку, исполняет,
          что сказала нейронка, доклеивает результаты в prompt, опять идет в нейронку и так далее и тому подобное. Очень
          просто, на самом деле, работает под капотом. Ну, не суть.</Notes>
      </Slide>

      {/* S26 — Уровень 1: Чат (+ files-to-prompt) */}
      <Slide>
        <Heading fontSize="h3">Уровень 1: Чат (+ files-to-prompt)</Heading>
        <UnorderedList>
          <ListItem><b>Когда:</b> маленькие задачи, отдельные файлы, короткие сниппеты, объяснения.</ListItem>
          <ListItem><b>Как:</b> «покормили» контентом, получили код/патч.</ListItem>
          <ListItem><b>Плюсы:</b> простота, скорость.</ListItem>
          <ListItem><b>Минусы:</b> ломается на больших diff (номера строк), легко потерять целостность.</ListItem>
          <ListItem><b>Шаблоны промптов:</b> «Дай патч для X», «Объясни файл Y в 5 пунктах», «Сделай минимальный пример
            для Z».</ListItem>
        </UnorderedList>
        <Notes>40–50 секунд. Малые задачи/файлы. Патчи ок до определённого размера. Дать 1–2 шаблона промптов.</Notes>
      </Slide>

      {/* S27 — Уровень 2: Большой контекст */}
      <Slide>
        <Heading fontSize="h3">Уровень 2: Большой контекст</Heading>
        <UnorderedList>
          <ListItem><b>Когда:</b> нужно «прочитать» проект, составить <b>план из ≤7 шагов</b>, сделать
            обзор/диагностику.</ListItem>
          <ListItem><b>Плюсы:</b> видит много, умеет планировать изменения.</ListItem>
          <ListItem><b>Минусы:</b> не всегда идеально «считает» патчи; нужна валидация.</ListItem>
          <ListItem><b>Шаблоны:</b> «Сделай план имплементации X с критериями готовности», «Найди, где фича-флаги
            отдаются на бэкенде».</ListItem>
        </UnorderedList>
        <Notes>Свяжи с навигацией по кодовой базе. План ≤7 шагов с критериями. Использовать для обзоров/диагностики.
          Подсветить необходимость валидации. Еще очень классно агентов использовать для навигации в неизвестной тебе
          кодовой базе. То есть, например, у тебя есть большой проект, в котором ни хера не понятно. Буквально вчера мне
          нужно было найти, какая ручка на бэкэнде отдает у нас фича-флаги. Ну я не знаю, как это искать. Я просто
          зашел, сказал агенту: «найди мне это». Охеренно работает. Очень часто выдает то, что нужно. В больших проектах
          просто кайф. Он просто взял там, пошуршал, что-то и нашел.</Notes>
      </Slide>

      {/* S28 — Уровень 3: Агенты (CLI/IDE) */}
      <Slide>
        <Heading fontSize="h3">Уровень 3: Агенты (CLI/IDE)</Heading>
        <UnorderedList>
          <ListItem><b>Когда:</b> применять план пошагово, навигация, мелкие рефакторы, генерация/правки по
            месту.</ListItem>
          <ListItem><b>Плюсы:</b> скорость, меньше копипасты, может сам применять изменения.</ListItem>
          <ListItem><b>Минусы/анти-паттерны:</b> зацикливание, неверная директория, пропуск файлов, чрезмерная
            автономность без валидации.</ListItem>
          <ListItem><b>Repair-приёмы:</b> <code>/compact</code>, перезапуск, «один шаг плана за раз», фиксировать
            «сделано» в файле.</ListItem>
        </UnorderedList>
        <Notes>60–70 секунд. Применять план шаг за шагом. Назвать анти-паттерны агента. Рецепты починки: /compact и т.п.
          Не совсем понятно про агентов. Можно просто использовать агента, чтобы там на полторы тысячи строк написать
          код, и всё будет тебе заебись. Нужно какое-то разграничение, когда вот только агенты использовать, будет ОК.
          То есть это размер, сколько ему нужно сгенерить или какая-то... Я, к сожалению, разграничение по вайбу. Ну, то
          есть, типа, вот это мы возвращаемся к… Спасибо за вопрос. Мы возвращаемся к тому приколу, который я говорил в
          начале, что пока что можно войти в цикл, когда ты борешься с нейронкой в попытках, чтобы она сгенерировала
          тебе то, что ты хочешь. И когда ты понимаешь, что она перестала генерить, что ты хочешь, что она перестала
          генерить рабочий код или перестала делать то, что ты хочешь, то нужно либо переходить в другой инструмент,
          либо нужно скомпактить диалог. Например, в Aider есть инструмент /compact. Ты её вызываешь, он, по сути, берет
          всю эту вот портянку, говорит нейронке: «вот все, что мы сделали, пожалуйста, сожми это до каких-то вот
          ключевых моментов, которые мы сделали», чтобы диалог стал типа из 120 тысяч токенов, стал там 2000 токенов с
          summary того, что мы сделали. Достаточно часто нейронки, точнее, агенты снова начинают нормально работать,
          потому что контекст не переполнен и снова можно эффективные результаты получать. Но с какого-то размера
          проекта, к сожалению, у тебя появляется больше файликов, нейронке становится сложнее производить какие-то
          эвристики для того, чтобы понять, какие файлы прочитать в проекте для того, чтобы решить твою задачу. То есть
          у тебя есть куча файлов в проекте, и агенту нужно типа вот посмотреть, какие файлы есть, прочитать этот,
          прочитать этот, прочитать этот, сгенерить какой-то новый результат, применить его везде. И с какого-то размера
          проекта, к сожалению, нейронки начинают пропускать какие-то куски, терять какие-то куски, выполнять какие-то
          команды, которые типа невыполнимы. Очень частая проблема в Aider, что он не знает, в какой папке он находится.
          Типа, он пытается исполнить команду не в той папке, у него не получается, он думает, что проблема не в том,
          что он не в той папке, а вообще какая-то другая. Он пытается перебирать команды и начинает входить в цикл. Ну,
          то есть вот целая куча разных проблем бывает в агентах, с которыми нужно, как бы, их нужно замечать и что-то с
          этим делать. Либо обнулить диалог, либо скомпактить диалог, либо вообще взять и перейти к гибридному формату,
          когда ты вот, который я описал, когда ты берешь всю кодовую базу, пихаешь и просишь, например, Gemini:
          «составь мне план имплементации». Когда он составил план, ты говоришь там агенту: «вот смотри, вот план,
          пожалуйста, положи его как файлик, начни выполнять первый пункт». Первый пункт выполнил, запиши в файлик, что
          первый пункт выполнил, пошел дальше. Вот, например, так вот. Ты можешь пробовать делать какие-то простые
          проекты сразу в агенте, но если замечаешь, что что-то идет не так, то искать пути обхода.</Notes>
      </Slide>

      {/* S29 — Матрица выбора инструмента (Task × Tool) */}
      <Slide>
        <Heading fontSize="h3">Матрица выбора инструмента (Task × Tool)</Heading>
        <Table>
          <TableHeader>
            <TableRow>
              <TableCell>Задача</TableCell>
              <TableCell>Чат</TableCell>
              <TableCell>files-to-prompt</TableCell>
              <TableCell>Большой контекст</TableCell>
              <TableCell>Агент</TableCell>
              <TableCell>Гибрид</TableCell>
            </TableRow>
          </TableHeader>
          <TableBody>
            {([
              ["Микро-утилита (одноразовая)", "✔︎", "✔︎", "", "", ""],
              ["Небольшой рефактор/фиксы", "✔︎", "✔︎", "", "✔︎", "✔︎"],
              ["Навигация в незнакомом проекте", "", "", "✔︎", "✔︎", "✔︎"],
              ["CI-проверки/линтеры-эвристики", "✔︎", "✔︎", "", "✔︎", ""],
              ["Генерация конфигов (YAML/Bash)", "✔︎", "✔︎", "", "", ""],
              ["Публичный сервис/интеграции", "", "", "✔︎ (план/ревью)", "", "✔︎"],
              ["Тестовый стенд/снапшоты", "", "", "✔︎", "✔︎", "✔︎"],
            ] as const).map((row, i) => (
              <TableRow key={i}>
                {row.map((cell, j) => <TableCell key={j}>{cell}</TableCell>)}
              </TableRow>
            ))}
          </TableBody>
        </Table>
        <Notes>✔︎ = «хороший базовый выбор». Поясни, что ✔︎ = базовый выбор. Приведи 1–2 быстрых примера. Связать с
          сигналами переключения.</Notes>
      </Slide>

      {/* S30 — Сигналы переключить инструмент */}
      <Slide>
        <Heading fontSize="h3">Сигналы переключить инструмент</Heading>
        <UnorderedList>
          <ListItem>Патч рвётся по строкам → к большому контексту/гибриду.</ListItem>
          <ListItem>Агент буксует 2 итерации → compact/перезапуск/гибрид.</ListItem>
          <ListItem>Контекст раздулся → делим задачи, суммаризируем диалог.</ListItem>
          <ListItem>Время LLM стабильно &gt; ручного → остановка/урезание фичи.</ListItem>
        </UnorderedList>
        <Notes>Показать как «дорожные знаки». 2 фейла подряд → смена подхода. Суммаризация/декомпозиция. Показать как
          «дорожные знаки».</Notes>
      </Slide>

      {/* S31 — Языки и ожидания */}
      <Slide>
        <Heading fontSize="h3">Языки и ожидания</Heading>
        <UnorderedList>
          <ListItem><b>По опыту:</b> Python &gt; TypeScript &gt; … &gt; Kotlin (прогресс есть, но всё ещё сложнее, чем
            Py/TS).</ListItem>
          <ListItem><b>Следствие:</b> для утилит не стесняйся выбирать язык, где модель сильнее.</ListItem>
          <ListItem style={{fontSize: '.85rem'}}><b>Дисклеймер:</b> эмпирика за 2024–2025, не истина в последней
            инстанции.</ListItem>
        </UnorderedList>
        <Notes>20–30 секунд. Сравнение по своему опыту. Подсветить прагматичный выбор языка. Оговорка: не аксиома. Судя
          по всему, на Питоне код пишется гораздо лучше, чем на чем бы то ни было, к сожалению большому. То есть если
          генерить на Питоне, то он прямо охуенно генерит. На втором месте TypeScript, ну а дальше уже посложнее. Со
          всяким Котлином, например, все очень плохо. Ну ладно, уже не очень плохо, но было достаточно плохо. И все
          равно сильно хуже, чем на Питоне, к сожалению. Как-то так.</Notes>
      </Slide>

      {/* S32 — Безопасность: минимум для маленьких ботов */}
      <Slide>
        <Heading fontSize="h3">Безопасность: минимум для маленьких ботов</Heading>
        <UnorderedList>
          <ListItem>Сужаем поверхность: только админ-команды/вайтлист.</ListItem>
          <ListItem>Секреты не в коде: env/secret manager.</ListItem>
          <ListItem>Пинить версии зависимостей; избегать «левых» пакетов.</ListItem>
          <ListItem>Логи/алерты (ошибки, аномальные баны, rate limit).</ListItem>
          <ListItem>Инпут-валидация даже «для своих».</ListItem>
        </UnorderedList>
        <Notes>Слайд-«памятка» для фото. Дай чек-лист для фото. Подчеркни важность для публичных сервисов. Свяжи с
          ботом.</Notes>
      </Slide>

      {/* S33 — Гибридный метод: обзор */}
      <Slide>
        <Heading fontSize="h3">Гибридный метод: План → Агент → Тесты</Heading>
        <UnorderedList>
          <ListItem>Большой контекст LLM делает план (≤7 шагов, критерии готовности, риски).</ListItem>
          <ListItem>Агент выполняет <b>один шаг</b>; фиксируем «сделано» в файле.</ListItem>
          <ListItem>После каждого шага — тест/снапшот.</ListItem>
          <ListItem>Застряли → compact/перезапуск/уточнение плана.</ListItem>
          <ListItem>Релиз → метрики/алерты.</ListItem>
        </UnorderedList>
        <Text style={{fontSize: '.9rem'}}>
          <b>Шаблон промпта «Сделай план»:</b> Цель; Ограничения; Критерии готовности; Риски; 5–7 шагов; проверка после
          каждого.
        </Text>
        <Notes>Дай 1 пример критерия готовности. Один шаг за раз через агента. После шага — тест или снапшот. Пример
          критерия готовности. Собственно, гибридный подход состоит в чем? Мы берем эти патчи, и так как они теперь уже,
          благодаря тому, что у нас есть кодинговые агенты, нам не нужно, чтобы эти патчи были типа идеальны. Мы можем
          просто скормить этот патч в агента, и он сам разберется, и достаточно неплохо разберется, и применит все эти
          изменения, и все будет хорошо. А если будет нехорошо, то мы можем взять опять весь этот репозиторий наш, либо
          патч с нашими изменениями, всунуть обратно в Gemini, сказать: «смотри, вот ты мне сказал, что надо сделать.
          Вот смотри, чё я сделал. Чё, нормально сделал? Если не нормально, то что надо починить?». Gemini берет и
          выплевывает тебе новый промпт, новые изменения, если вдруг что-то надо починить, или хвалит тебя, говорит, что
          «агент сделал всё заебись, все классно». Ну, вот это такой вот гибридный подход, который, в принципе,
          достаточно неплохо у меня работает. Ну, и есть, конечно, совсем не гибридный подход, когда ты просто напрямую
          используешь кодингового агента. Достаточно большое количество задач решается просто в диалоге вот с Aider
          каким-нибудь, например. То есть ты можешь взять, создать новый проект, навайп-кодить какую-нибудь херню на
          Питоне до пары тысяч строк кода и идеально все будет работать с большой долей вероятности, и все будет
          офигенно.</Notes>
      </Slide>

      {/* S34 — Рецепт snapshot-тестов «чёрного ящика» */}
      <Slide>
        <Heading fontSize="h3">Рецепт snapshot-тестов «чёрного ящика»</Heading>
        <UnorderedList>
          <ListItem>Собрать реальные вебхуки за короткий период.</ListItem>
          <ListItem>Поднять сервис + БД локально/в тест-контейнере.</ListItem>
          <ListItem>Прогнать наборы вебхуков → зафиксировать состояние БД в файлы.</ListItem>
          <ListItem>При изменениях — прогонять снова; diff ≠ 0 → разбираться.</ListItem>
          <ListItem>Минимум 2 набора: happy-path и fail-path.</ListItem>
        </UnorderedList>
        <Notes>Связать с Webhook Explorer. Подчеркнуть «реальные» входные события. Два набора: happy / fail. Ссылка на
          Explorer.</Notes>
      </Slide>

      {/* S35 — Таймбоксы и anti-sunk cost */}
      <Slide>
        <Heading fontSize="h3">Таймбоксы и anti-sunk cost</Heading>
        <UnorderedList>
          <ListItem>Микро-тулза: ≤15 мин (или бросаем/упрощаем).</ListItem>
          <ListItem>2 подряд провальные итерации с агентом → меняем инструмент.</ListItem>
          <ListItem>40 мин без прогресса → стоп/переформулировать.</ListItem>
          <ListItem>Мем про вагонетку: «остановить можно сейчас — иначе прошлые жертвы окажутся зря».</ListItem>
        </UnorderedList>
        <Notes>Коротко и с улыбкой. Озвучить личные лимиты времени. 2 фейла → смена подхода. Мем про вагонетку для
          запоминания.</Notes>
      </Slide>

      {/* S36 — График: размер проекта vs эффективность вайба */}
      <Slide>
        <Heading fontSize="h3">Размер проекта vs эффективность вайба</Heading>
        <Text>Линия 1: <b>Эффективность чистого вайбкодинга</b> ↓ с ростом размера.</Text>
        <Text>Линия 2: <b>Удовольствие разработчика</b> ↓ после «сладкой точки».</Text>
        <Text>Отметить «sweet spot» для микротулз и «зона гибрида».</Text>
        <Text><Todo>Нарисовать простой line chart</Todo></Text>
        <Notes>20 секунд, перейти к выводам. Две кривые + sweet spot. Где заканчивается «чистый вайб». Подвести к
          выводам.</Notes>
      </Slide>

      {/* S37 — Когда благо, когда блажь */}
      <Slide>
        <Heading fontSize="h3">Когда благо, когда блажь</Heading>
        <div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1.25rem'}}>
          <Box>
            <Heading fontSize="h4">Благо</Heading>
            <UnorderedList>
              <ListItem>Маленькие приватные тулзы</ListItem>
              <ListItem>Быстрые эксперименты</ListItem>
              <ListItem>Тестовые стенды</ListItem>
              <ListItem>Навигация по коду</ListItem>
            </UnorderedList>
          </Box>
          <Box>
            <Heading fontSize="h4">Блажь</Heading>
            <UnorderedList>
              <ListItem>Публичные сервисы без ревью</ListItem>
              <ListItem>Погони за «идеальным стеком»</ListItem>
              <ListItem>Игнор тестов/политик</ListItem>
              <ListItem>Слепое доверие агенту</ListItem>
            </UnorderedList>
          </Box>
        </div>
        <Notes>Привяжи к двум кейсам. Соотнести с двумя кейсами. Подчеркнуть «рамки применения». Мост к финальному
          чек-листу.</Notes>
      </Slide>

      {/* S38 — Итоговый чек-лист */}
      <Slide>
        <Heading fontSize="h3">Итоговый чек-лист</Heading>
        <UnorderedList>
          <ListItem>План ≤7 шагов + критерии.</ListItem>
          <ListItem>Малые итерации; после каждой — тест/снапшот.</ListItem>
          <ListItem>Таймбоксы и стоп-критерии.</ListItem>
          <ListItem>Мини-полиси безопасности.</ListItem>
          <ListItem>Матрица выбора инструмента.</ListItem>
          <ListItem>Пост-мортем и правила команды.</ListItem>
        </UnorderedList>
        <Text>Финальный тезис — «Вайбкодинг — благо в рамках».</Text>
        <Notes>Слайд «фото и в путь». Подчеркнуть дисциплину процесса. Снимать магию → оставлять результат.
          Поблагодарить аудиторию перед Q&A.</Notes>
      </Slide>

      {/* S39 — Q&A */}
      <Slide>
        <Heading fontSize="h3">Q&amp;A</Heading>
        <Text>Спасибо!</Text>
        <Notes>Держи 2–3 заранее подготовленных ответа (безопасность, выбор инструмента, языки). Готовые ответы:
          безопасность / выбор инструмента / языки. Если спросят цифры — сослаться на S2/S6. Предложить поделиться
          репкой/слайдами. Ты говоришь про Gemini и Gemini 1.5, говори как-нибудь одинаково, чтобы не путать. А ты
          презентацию тоже будешь вайб-кодить? Да, можешь тоже сказать, что можно вайб-кодить презентацию, например,
          тоже. На TypeScript, скорее всего, буду её вайб-кодить. В смысле, можешь типа поделиться со своей аудиторией,
          что доклад с помощью вайб-кодинга, в том числе, был сделан. Блин, вот мне, на самом деле, тяжело, что доклад
          про вайбкодинг, я совершенно не раскрываю огромную сферу применения нейронок вне вайпкодинга. Типа, как я
          использую нейронки. Например, то, что я транскрибирую. Тут надо по теме доклада говорить. Я просто накидываю в
          микрофон, чтобы можно было потом раскрыть. То есть его можно расширить очень сильно, этот доклад, либо вообще
          на другие темы поговорить. У меня там пиздец, сколько контента, оказывается. Я экспортнул все свои разговоры и
          охуел, если честно. Ну, разговоры? Ну, я экспортнул все, что я делал в чат GPT за все время, что я им
          пользуюсь. Там всякие наши маврикийские приколы, всё там. Как это давно было.</Notes>
      </Slide>

      {/* S40 — Бэкап: доп. сниппеты */}
      <Slide>
        <Heading fontSize="h3">Бэкап: доп. сниппеты</Heading>
        <Text><Todo>Добавить сниппеты кода из кейсов</Todo></Text>
        <Notes>Для Q&A: дополнительные примеры кода.</Notes>
      </Slide>

      {/* S41 — Бэкап: таблица языков */}
      <Slide>
        <Heading fontSize="h3">Бэкап: таблица языков</Heading>
        <Table>
          <TableHeader>
            <TableRow>
              <TableCell>Язык</TableCell>
              <TableCell>Эффективность</TableCell>
              <TableCell>Комментарии</TableCell>
            </TableRow>
          </TableHeader>
          <TableBody>
            <TableRow>
              <TableCell>Python</TableCell>
              <TableCell>Высокая</TableCell>
              <TableCell>Лучший для утилит</TableCell>
            </TableRow>
            <TableRow>
              <TableCell>TypeScript</TableCell>
              <TableCell>Средняя</TableCell>
              <TableCell>Хорош для веб</TableCell>
            </TableRow>
            <TableRow>
              <TableCell>Kotlin</TableCell>
              <TableCell>Низкая</TableCell>
              <TableCell>Сложнее генерить</TableCell>
            </TableRow>
          </TableBody>
        </Table>
        <Notes>Для Q&A: сравнение языков.</Notes>
      </Slide>

      {/* S42 — Бэкап: чек-лист «починить агента» */}
      <Slide>
        <Heading fontSize="h3">Бэкап: чек-лист «починить агента»</Heading>
        <UnorderedList>
          <ListItem>/compact диалог</ListItem>
          <ListItem>Перезапуск</ListItem>
          <ListItem>Один шаг за раз</ListItem>
          <ListItem>Summary прогресса</ListItem>
          <ListItem>Проверить директорию</ListItem>
        </UnorderedList>
        <Notes>Для Q&A: как фиксить агентов.</Notes>
      </Slide>

      {/* S43 — Бэкап: полезные ссылки */}
      <Slide>
        <Heading fontSize="h3">Бэкап: полезные ссылки</Heading>
        <UnorderedList>
          <ListItem>Aider</ListItem>
          <ListItem>Cursor</ListItem>
          <ListItem>Copilot</ListItem>
          <ListItem>Shotgun Code</ListItem>
          <ListItem>Files-to-prompt</ListItem>
        </UnorderedList>
        <Notes>Для Q&A: инструменты без логотипов.</Notes>
      </Slide>
    </Deck>
  );
}
